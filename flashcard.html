i<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>German-English Flashcards v2.4 - Enhanced Voice Options</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg?v=2.4.1">
    <link rel="alternate icon" href="favicon.ico?v=2.4.1">
    <link rel="shortcut icon" href="favicon.ico?v=2.4.1">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 20px;
            overflow-y: auto;
        }

        .container {
            width: 100%;
            max-width: 600px;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            margin-top: 20px;
            margin-bottom: 40px;
        }

        h1 {
            text-align: center;
            color: #667eea;
            margin-bottom: 30px;
            font-size: 2em;
        }

        .upload-section {
            margin-bottom: 30px;
            text-align: center;
        }

        .upload-label {
            display: inline-block;
            padding: 12px 30px;
            background: #667eea;
            color: white;
            border-radius: 10px;
            cursor: pointer;
            transition: background 0.3s;
            font-weight: 600;
        }

        .upload-label:hover {
            background: #5568d3;
        }

        #csvFile {
            display: none;
        }

        .file-info {
            margin-top: 10px;
            color: #666;
            font-size: 0.9em;
            line-height: 1.6;
        }

        .file-info strong {
            color: #667eea;
            font-size: 1.1em;
        }

        .flashcard-container {
            display: none;
            margin-bottom: 30px;
        }

        .flashcard {
            position: relative;
            width: 100%;
            background: white;
            border-radius: 15px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .card-german-section {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px 30px;
            text-align: center;
            position: relative;
        }

        .card-label {
            font-size: 0.8em;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 15px;
            opacity: 0.9;
        }

        .card-content {
            font-size: 2.5em;
            font-weight: 700;
            text-align: center;
            word-wrap: break-word;
            margin: 20px 0;
        }

        .card-divider {
            border: none;
            border-top: 2px dashed rgba(255, 255, 255, 0.3);
            margin: 20px 0;
        }

        .card-english-section {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            padding: 30px;
            text-align: center;
            max-height: 0;
            opacity: 0;
            overflow: hidden;
            transition: all 0.4s ease-in-out;
        }

        .card-english-section.revealed {
            max-height: 300px;
            opacity: 1;
            padding: 40px 30px;
        }

        .reveal-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white;
            padding: 10px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
            transition: all 0.3s;
            margin-top: 10px;
        }

        .reveal-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }

        .card-detail {
            font-size: 0.9em;
            margin-top: 15px;
            opacity: 0.9;
            font-style: italic;
            text-align: center;
        }

        .navigation {
            display: none;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
        }

        .nav-button {
            padding: 12px 30px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: background 0.3s;
        }

        .nav-button:hover:not(:disabled) {
            background: #5568d3;
        }

        .nav-button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .progress {
            text-align: center;
            color: #667eea;
            font-weight: 600;
            font-size: 1.1em;
        }

        .hint {
            text-align: center;
            color: #999;
            font-size: 0.9em;
            margin-top: 10px;
        }

        .show-meanings-toggle {
            display: none;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin: 15px 0;
            padding: 12px;
            background: #f0f9ff;
            border-radius: 10px;
        }

        .show-meanings-toggle label {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            font-weight: 600;
            color: #667eea;
            user-select: none;
        }

        .show-meanings-toggle input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: #667eea;
        }

        .control-buttons {
            display: none;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin: 20px 0;
        }

        .control-btn {
            padding: 10px 20px;
            background: #10b981;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
            transition: background 0.3s;
        }

        .control-btn:hover {
            background: #059669;
        }

        .control-btn.active {
            background: #f59e0b;
        }

        .autoplay-btn {
            background: #8b5cf6;
        }

        .autoplay-btn:hover {
            background: #7c3aed;
        }

        .autoplay-btn.playing {
            background: #ef4444;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .autoplay-settings {
            display: none;
            background: #f9fafb;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border: 2px solid #e5e7eb;
        }

        .category-manager {
            display: none;
            background: #fef3c7;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border: 2px solid #f59e0b;
        }

        .category-manager h4 {
            margin: 0 0 10px 0;
            color: #d97706;
        }

        .category-section {
            margin: 10px 0;
        }

        .category-input-group {
            display: flex;
            gap: 8px;
            margin: 8px 0;
        }

        .category-input-group input,
        .category-input-group select {
            padding: 6px 10px;
            border: 2px solid #fbbf24;
            border-radius: 6px;
            font-size: 0.9em;
        }

        .category-input-group button {
            padding: 6px 15px;
            background: #f59e0b;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
        }

        .category-input-group button:hover {
            background: #d97706;
        }

        .category-list {
            background: white;
            border: 2px solid #fbbf24;
            border-radius: 6px;
            padding: 10px;
            margin: 10px 0;
            max-height: 200px;
            overflow-y: auto;
        }

        .category-item {
            padding: 8px;
            margin: 4px 0;
            background: #fffbeb;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .category-item:hover {
            background: #fef3c7;
        }

        .subcategory-item {
            margin-left: 20px;
            padding: 6px;
            font-size: 0.9em;
            background: #fefce8;
        }

        .category-badge {
            display: inline-block;
            padding: 2px 8px;
            background: #fbbf24;
            color: #78350f;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: 600;
        }

        .btn-small {
            padding: 3px 8px;
            font-size: 0.8em;
            margin-left: 5px;
        }

        .advanced-settings {
            display: none;
            background: #dbeafe;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border: 2px solid #3b82f6;
        }

        .advanced-settings h4 {
            margin: 0 0 10px 0;
            color: #1e40af;
        }

        .timer-display {
            background: #fee2e2;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            margin: 10px 0;
            font-size: 1.2em;
            font-weight: bold;
            color: #991b1b;
            display: none;
        }

        .session-stats {
            background: #d1fae5;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            display: none;
        }

        .session-stats h4 {
            margin: 0 0 10px 0;
            color: #065f46;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #a7f3d0;
        }

        .stat-label {
            color: #047857;
            font-weight: 600;
        }

        .stat-value {
            color: #065f46;
            font-weight: bold;
        }

        .focus-mode {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #1f2937;
            z-index: 9999;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .focus-mode .container {
            background: #374151;
            max-width: 800px;
        }

        .focus-mode .flashcard {
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
        }

        .focus-exit-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #ef4444;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            z-index: 10000;
        }

        .focus-exit-btn:hover {
            background: #dc2626;
        }

        .autoplay-settings label {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 8px 0;
            font-size: 0.9em;
            color: #374151;
        }

        .voice-settings {
            display: none;
            background: #fef3c7;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border: 2px solid #fbbf24;
        }

        .voice-settings h4 {
            margin: 0 0 10px 0;
            color: #d97706;
        }

        .voice-settings label {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
            font-size: 0.9em;
            color: #92400e;
        }

        .voice-settings select {
            flex: 1;
            padding: 6px 10px;
            border: 2px solid #fbbf24;
            border-radius: 6px;
            background: white;
            font-size: 0.9em;
            cursor: pointer;
        }

        .voice-settings input[type="range"] {
            flex: 1;
            cursor: pointer;
            accent-color: #f59e0b;
        }

        .autoplay-settings input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #8b5cf6;
        }

        .autoplay-settings input[type="range"] {
            flex: 1;
            cursor: pointer;
            accent-color: #8b5cf6;
        }

        .delay-value {
            font-weight: 600;
            color: #8b5cf6;
            min-width: 50px;
            text-align: right;
        }

        .learned-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #10b981;
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.8em;
            font-weight: 600;
            z-index: 10;
        }

        .stats {
            display: none;
            background: #f0f9ff;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            text-align: center;
        }

        .stats-item {
            display: inline-block;
            margin: 0 15px;
            color: #667eea;
            font-weight: 600;
        }

        .stats-value {
            font-size: 1.5em;
            display: block;
        }

        .audio-btn {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            font-size: 1.5em;
            cursor: pointer;
            transition: all 0.3s;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .audio-btn:hover {
            background: rgba(255, 255, 255, 0.5);
            transform: scale(1.1);
        }

        .audio-btn-english {
            position: relative;
            top: auto;
            left: auto;
            margin: 15px auto 0 auto;
            background: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            font-size: 1.5em;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .audio-btn-english:hover {
            background: rgba(255, 255, 255, 0.5);
            transform: scale(1.1);
        }

        .review-info {
            font-size: 0.75em;
            color: rgba(255, 255, 255, 0.8);
            margin-top: 10px;
            text-align: center;
        }

        .format-selector {
            background: #f8fafc;
            padding: 25px;
            border-radius: 15px;
            margin: 20px 0;
            border: 3px solid #667eea;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
        }

        .format-selector h3 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .format-option {
            transition: all 0.3s;
        }

        .format-option:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15);
        }

        .format-preset-btn {
            padding: 15px;
            background: white;
            border: 2px solid #0284c7;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            font-size: 0.9em;
        }

        .format-preset-btn:hover {
            background: #0284c7;
            color: white;
            transform: scale(1.05);
        }

        .format-preset-btn strong {
            display: block;
            margin-bottom: 8px;
        }

        .column-mapper {
            background: #f0f9ff;
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            border: 3px solid #667eea;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
            overflow: visible;
        }

        .column-mapper h3 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .column-mapper p {
            color: #666;
            font-size: 0.95em;
        }

        #dataPreviewTable {
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        #dataPreviewTable th {
            padding: 18px 12px;
            text-align: center;
            font-weight: 600;
            font-size: 0.95em;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            user-select: none;
            border: 4px solid #e5e7eb;
            background: #f9fafb;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        #dataPreviewTable th:hover {
            background: #fef3c7;
            border-color: #fbbf24;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        #dataPreviewTable th::before {
            content: 'üëÜ Click to Select Type';
            display: block;
            font-size: 0.7em;
            font-weight: normal;
            color: #f59e0b;
            margin-bottom: 5px;
            animation: bounce 2s infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-3px); }
        }

        #dataPreviewTable th.selected {
            background: #667eea;
            color: white;
            border: 4px solid #667eea;
        }

        #dataPreviewTable th.type-german {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border: 4px solid #10b981;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
        }

        #dataPreviewTable th.type-german::before {
            content: '‚úì Selected';
            color: white;
            animation: none;
        }

        #dataPreviewTable th.type-germanExtended {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
            border: 4px solid #f59e0b;
            box-shadow: 0 4px 12px rgba(245, 158, 11, 0.4);
        }

        #dataPreviewTable th.type-germanExtended::before {
            content: '‚úì Selected';
            color: white;
            animation: none;
        }

        #dataPreviewTable th.type-english {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: white;
            border: 4px solid #3b82f6;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        #dataPreviewTable th.type-english::before {
            content: '‚úì Selected';
            color: white;
            animation: none;
        }

        #dataPreviewTable th.type-englishExtended {
            background: linear-gradient(135deg, #ec4899 0%, #db2777 100%);
            color: white;
            border: 4px solid #ec4899;
            box-shadow: 0 4px 12px rgba(236, 72, 153, 0.4);
        }

        #dataPreviewTable th.type-englishExtended::before {
            content: '‚úì Selected';
            color: white;
            animation: none;
        }

        #dataPreviewTable th.type-ignore {
            background: #94a3b8;
            color: white;
            border: 4px solid #94a3b8;
            opacity: 0.5;
        }

        #dataPreviewTable th.type-ignore::before {
            content: '‚úó Ignored';
            color: white;
            animation: none;
        }

        #dataPreviewTable td {
            padding: 10px 12px;
            border-bottom: 1px solid #e5e7eb;
            max-width: 250px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        #dataPreviewTable tr:last-child td {
            border-bottom: none;
        }

        #dataPreviewTable tr:nth-child(even) {
            background: #f9fafb;
        }

        .column-type-selector {
            position: fixed;
            background: white;
            border: 4px solid #667eea;
            border-radius: 12px;
            padding: 12px;
            z-index: 10000;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            display: none;
            width: 280px;
            max-height: 350px;
            overflow-y: auto;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        .column-type-selector.active {
            animation: slideDown 0.2s ease-out;
        }

        .column-type-selector::-webkit-scrollbar {
            width: 8px;
        }

        .column-type-selector::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 4px;
        }

        .column-type-selector::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 4px;
        }

        .column-type-selector::-webkit-scrollbar-thumb:hover {
            background: #5568d3;
        }

        .type-option {
            padding: 10px 12px;
            margin: 4px 0;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.85em;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            border: 2px solid transparent;
        }

        .type-option small {
            display: block;
            font-size: 0.8em;
            line-height: 1.2;
        }

        .type-option:hover {
            transform: translateX(2px);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        }

        .type-option:active {
            transform: translateX(0);
        }

        .type-option[style*="color: #10b981"]:hover {
            background: #d1fae5;
            border-color: #10b981;
        }

        .type-option[style*="color: #f59e0b"]:hover {
            background: #fef3c7;
            border-color: #f59e0b;
        }

        .type-option[style*="color: #3b82f6"]:hover {
            background: #dbeafe;
            border-color: #3b82f6;
        }

        .type-option[style*="color: #ec4899"]:hover {
            background: #fce7f3;
            border-color: #ec4899;
        }

        .type-option[style*="color: #94a3b8"]:hover {
            background: #f1f5f9;
            border-color: #94a3b8;
        }

        .instructions {
            background: #f7f7f7;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-size: 0.9em;
            color: #666;
        }

        .instructions h3 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .instructions code {
            background: #e0e0e0;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
        }

        /* Settings Menu Styles */
        .settings-menu {
            display: none;
            background: #f8fafc;
            border-radius: 15px;
            padding: 15px;
            margin: 20px 0;
            border: 2px solid #e2e8f0;
            max-height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
            scroll-behavior: smooth;
            position: relative;
        }

        .settings-menu::-webkit-scrollbar {
            width: 10px;
        }

        .settings-menu::-webkit-scrollbar-track {
            background: #e2e8f0;
            border-radius: 10px;
        }

        .settings-menu::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 10px;
        }

        .settings-menu::-webkit-scrollbar-thumb:hover {
            background: #5568d3;
        }

        .settings-toggle-btn {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: space-between;
            margin: 15px 0;
            transition: all 0.3s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .settings-toggle-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }

        .settings-toggle-btn.active {
            background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
        }

        .toggle-icon {
            font-size: 1.2em;
            transition: transform 0.3s;
        }

        .settings-toggle-btn.active .toggle-icon {
            transform: rotate(180deg);
        }

        .accordion-item {
            background: white;
            border-radius: 10px;
            margin: 10px 0;
            overflow: hidden;
            border: 2px solid #e2e8f0;
            transition: all 0.3s;
        }

        .accordion-item:hover {
            border-color: #cbd5e1;
        }

        .accordion-header {
            padding: 15px 20px;
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
            color: #334155;
            user-select: none;
            transition: all 0.3s;
        }

        .accordion-header:hover {
            background: linear-gradient(135deg, #e2e8f0 0%, #cbd5e1 100%);
        }

        .accordion-header.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .accordion-icon {
            font-size: 1.2em;
            transition: transform 0.3s;
        }

        .accordion-header.active .accordion-icon {
            transform: rotate(180deg);
        }

        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease-out, padding 0.4s ease-out;
            padding: 0 20px;
        }

        .accordion-content.active {
            max-height: 2000px;
            padding: 20px;
            transition: max-height 0.5s ease-in, padding 0.4s ease-in;
        }

        .quick-actions {
            display: none;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }

        .quick-action-btn {
            padding: 12px 20px;
            background: white;
            border: 2px solid #667eea;
            color: #667eea;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9em;
        }

        .quick-action-btn:hover {
            background: #667eea;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.3);
        }

        .quick-action-btn.active {
            background: #667eea;
            color: white;
        }

        /* Fix accordion content labels */
        .accordion-content label {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
            font-size: 0.95em;
            color: #334155;
        }

        .accordion-content label span {
            flex: 1;
        }

        .accordion-content label select,
        .accordion-content label input[type="range"] {
            flex: 2;
        }

        /* Modal Popup Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            animation: fadeIn 0.3s ease-out;
            overflow-y: auto;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background: white;
            border-radius: 20px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            overflow-x: visible;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
            animation: slideUp 0.3s ease-out;
            position: relative;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 3px solid #667eea;
        }

        .modal-header h3 {
            margin: 0;
            color: #667eea;
            font-size: 1.5em;
        }

        .modal-close {
            background: #ef4444;
            color: white;
            border: none;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            font-size: 1.2em;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            font-weight: bold;
        }

        .modal-close:hover {
            background: #dc2626;
            transform: scale(1.1);
        }

        .modal-body {
            padding: 10px 0;
            padding-bottom: 450px;
        }

        .modal-body > p {
            color: #666;
            margin-bottom: 20px;
            font-size: 0.95em;
        }

        .type-choice-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
        }

        .type-choice-card {
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            border: 3px solid #e2e8f0;
            border-radius: 12px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }

        .type-choice-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
        }

        .type-choice-card[data-type="german"]:hover {
            border-color: #10b981;
            background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);
        }

        .type-choice-card[data-type="germanExtended"]:hover {
            border-color: #f59e0b;
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
        }

        .type-choice-card[data-type="english"]:hover {
            border-color: #3b82f6;
            background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
        }

        .type-choice-card[data-type="englishExtended"]:hover {
            border-color: #ec4899;
            background: linear-gradient(135deg, #fce7f3 0%, #fbcfe8 100%);
        }

        .type-choice-card[data-type="ignore"]:hover {
            border-color: #94a3b8;
            background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%);
        }

        .type-icon {
            font-size: 3em;
            margin-bottom: 10px;
        }

        .type-name {
            font-size: 1.1em;
            font-weight: 600;
            color: #334155;
            margin-bottom: 8px;
        }

        .type-desc {
            font-size: 0.85em;
            color: #64748b;
            line-height: 1.4;
        }

        /* Dropdown Selector Styles (inside modal) */
        .column-type-selector {
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-top: 5px;
            background: white;
            border: 4px solid #667eea;
            border-radius: 12px;
            padding: 12px;
            z-index: 20000;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            display: none;
            width: 280px;
            max-height: 400px;
            overflow-y: auto;
        }

        .column-type-selector.active {
            display: block !important;
        }

        .column-type-selector::-webkit-scrollbar {
            width: 8px;
        }

        .column-type-selector::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 4px;
        }

        .column-type-selector::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 4px;
        }

        .type-option {
            padding: 10px 12px;
            margin: 4px 0;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.85em;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            border: 2px solid transparent;
        }

        .type-option small {
            display: block;
            font-size: 0.8em;
            line-height: 1.2;
        }

        .type-option:hover {
            transform: translateX(2px);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        }

        .type-option[style*="color: #10b981"]:hover {
            background: #d1fae5;
            border-color: #10b981;
        }

        .type-option[style*="color: #f59e0b"]:hover {
            background: #fef3c7;
            border-color: #f59e0b;
        }

        .type-option[style*="color: #3b82f6"]:hover {
            background: #dbeafe;
            border-color: #3b82f6;
        }

        .type-option[style*="color: #ec4899"]:hover {
            background: #fce7f3;
            border-color: #ec4899;
        }

        .type-option[style*="color: #94a3b8"]:hover {
            background: #f1f5f9;
            border-color: #94a3b8;
        }

        .category-browser {
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @media (max-width: 480px) {
            .container {
                padding: 20px;
            }

            h1 {
                font-size: 1.5em;
            }

            .flashcard {
                height: 250px;
            }

            .card-content {
                font-size: 1.5em;
            }

            .nav-button {
                padding: 10px 20px;
                font-size: 0.9em;
            }

            #categoryBrowserList {
                grid-template-columns: 1fr !important;
            }

            /* Modal responsive adjustments */
            .modal-content {
                width: 95%;
                padding: 20px;
            }

            .type-choice-grid {
                grid-template-columns: 1fr;
                gap: 10px;
            }

            .type-choice-card {
                padding: 15px;
            }

            .type-icon {
                font-size: 2.5em;
            }

            .modal-header h3 {
                font-size: 1.2em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üá©üá™ German-English Flashcards <span style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 3px 12px; border-radius: 15px; font-size: 0.7em; vertical-align: middle;">v2.4</span> üá¨üáß</h1>

        <!-- Category Browser (Always Visible) - Practice existing vocabulary -->
        <div class="category-browser" id="categoryBrowser" style="background: #f0f9ff; padding: 20px; border-radius: 15px; margin-bottom: 20px; border: 3px solid #667eea;">
            <h3 style="color: #667eea; margin-bottom: 15px;">üìö Your Vocabulary Categories</h3>
            <p style="color: #666; font-size: 0.9em; margin-bottom: 15px;">Browse and practice your saved vocabulary organized by categories</p>
            <div id="categoryBrowserList" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 10px;">
                <!-- Will be populated dynamically -->
            </div>
            <div id="noCategoriesMessage" style="text-align: center; color: #999; padding: 20px; display: none;">
                No categories yet. Upload a file to get started!
            </div>
        </div>

        <!-- Upload Section (Always Visible) -->
        <div class="upload-section">
            <label for="csvFile" class="upload-label">
                üìÅ Choose Vocabulary File
            </label>
            <input type="file" id="csvFile" accept="*">
            <div class="file-info" id="fileInfo"></div>
            <button class="upload-label" id="clearFileBtn" style="background: #ef4444; display: none; margin-top: 10px;">
                üóëÔ∏è Remove Current File
            </button>
        </div>

        <!-- Category Suggestion Box (MOVED OUTSIDE - Always visible when suggestion exists) -->
        <div class="category-section" id="suggestedCategorySection" style="display: none; background: #fef3c7; padding: 20px; border-radius: 12px; margin: 20px 0; border: 3px solid #f59e0b; box-shadow: 0 6px 12px rgba(245, 158, 11, 0.3);">
            <strong style="color: #92400e; font-size: 1.2em; display: block; margin-bottom: 10px;">üí° Suggested Categories</strong>
            <p style="color: #78350f; font-size: 0.95em; margin: 0 0 15px 0;">Based on your filename and content analysis:</p>

            <div style="background: white; padding: 15px; border-radius: 10px; margin-bottom: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                <div style="margin-bottom: 12px;">
                    <label style="display: block; color: #92400e; font-weight: 600; margin-bottom: 6px;">üìÅ Category:</label>
                    <input type="text" id="suggestedCategoryInput" style="width: 100%; padding: 10px; border: 2px solid #fbbf24; border-radius: 8px; font-size: 1em;">
                </div>
                <div>
                    <label style="display: block; color: #92400e; font-weight: 600; margin-bottom: 6px;">üìã Subcategory (optional):</label>
                    <input type="text" id="suggestedSubcategoryInput" style="width: 100%; padding: 10px; border: 2px solid #fbbf24; border-radius: 8px; font-size: 1em;">
                    <small style="color: #78350f; font-style: italic; display: block; margin-top: 5px;">Leave empty if no subcategory needed</small>
                </div>
            </div>

            <div style="display: flex; gap: 12px;">
                <button onclick="applySuggestedCategory()" style="flex: 1; padding: 12px 18px; background: #10b981; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 1.05em; transition: all 0.2s;">
                    ‚úì Accept & Apply
                </button>
                <button onclick="rejectSuggestion()" style="flex: 1; padding: 12px 18px; background: #94a3b8; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 1.05em; transition: all 0.2s;">
                    ‚úó Use Default Instead
                </button>
            </div>
        </div>

        <!-- Manual Suggestion Display Button -->
        <div style="margin-bottom: 20px;">
            <button onclick="testAutoOpen()" style="display: block; width: 100%; padding: 12px; background: #3b82f6; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 1em;" id="testAutoOpenBtn">
                üí° Show Category Suggestion
            </button>
        </div>

        <!-- Category Management (Always Visible, Collapsible) -->
        <div style="margin-bottom: 20px;">
            <button class="settings-toggle-btn" id="categoryMgmtToggleBtn" style="display: flex; background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);">
                <span>üìö Manage Categories</span>
                <span class="toggle-icon">‚ñº</span>
            </button>
            <div class="category-manager" id="categoryManagerSection" style="display: none; margin-top: 10px;">
                <h4 style="color: #d97706;">Category Management</h4>

                <div class="category-section">
                    <strong>Current File:</strong>
                    <span id="currentFileDisplay">No file loaded</span>
                    <span class="category-badge" id="currentCategoryBadge">Default</span>
                </div>
                <div class="category-section">
                    <label style="display: block; margin-bottom: 5px;">Assign to Category:</label>
                    <div class="category-input-group">
                        <select id="categorySelect" style="flex: 1;">
                            <option value="Default">Default</option>
                        </select>
                        <select id="subcategorySelect" style="flex: 1;">
                            <option value="">No Subcategory</option>
                        </select>
                        <button onclick="assignCategory()">Assign</button>
                    </div>
                </div>
                <hr style="border: 1px solid #e2e8f0; margin: 15px 0;">
                <div class="category-section">
                    <strong>Create New Category:</strong>
                    <div class="category-input-group">
                        <input type="text" id="newCategoryName" placeholder="e.g., German" style="flex: 1;">
                        <button onclick="createCategory()">+ Add Category</button>
                    </div>
                </div>
                <div class="category-section">
                    <strong>Add Subcategory:</strong>
                    <div class="category-input-group">
                        <select id="parentCategorySelect" style="flex: 1;">
                            <option value="Default">Default</option>
                        </select>
                        <input type="text" id="newSubcategoryName" placeholder="e.g., A1 Vocabulary" style="flex: 1;">
                        <button onclick="createSubcategory()">+ Add Sub</button>
                    </div>
                </div>
                <div class="category-section">
                    <strong>All Categories:</strong>
                    <div class="category-list" id="categoryList">
                        <div class="category-item">
                            <span>üìÅ Default</span>
                            <span style="font-size: 0.8em; color: #78350f;">Built-in</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Format Selection Interface -->
        <div class="format-selector" id="formatSelector" style="display: none;">
            <h3>üìã Choose How to Load Your File</h3>
            <p style="margin-bottom: 20px; color: #666;">Select the best method for your CSV format:</p>

            <!-- Option 1: Predefined Formats -->
            <div class="format-option" style="background: #e0f2fe; border: 3px solid #0284c7; padding: 20px; border-radius: 12px; margin-bottom: 15px; cursor: pointer;" onclick="selectPredefinedFormat()">
                <h4 style="color: #0284c7; margin: 0 0 10px 0;">‚ö° Option 1: Quick Predefined Format</h4>
                <p style="margin: 0 0 15px 0; font-size: 0.9em; color: #666;">Choose from common CSV formats. Fastest option!</p>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;" id="predefinedFormats">
                    <button class="format-preset-btn" data-format="3col-standard">
                        <strong>üìå 3-Column Standard</strong><br>
                        <span style="font-size: 0.85em;">German, German Example, English</span>
                    </button>
                    <button class="format-preset-btn" data-format="3col-reverse">
                        <strong>üìå 3-Column Reverse</strong><br>
                        <span style="font-size: 0.85em;">English, English Example, German</span>
                    </button>
                    <button class="format-preset-btn" data-format="4col-full">
                        <strong>üìå 4-Column Full</strong><br>
                        <span style="font-size: 0.85em;">German, German Ex., English, English Ex.</span>
                    </button>
                    <button class="format-preset-btn" data-format="2col-simple">
                        <strong>üìå 2-Column Simple</strong><br>
                        <span style="font-size: 0.85em;">German, English (no examples)</span>
                    </button>
                </div>
            </div>

            <!-- Option 2: Manual Mapping -->
            <div class="format-option" style="background: #fef3c7; border: 3px solid #f59e0b; padding: 20px; border-radius: 12px; margin-bottom: 15px; cursor: pointer;" onclick="selectManualMapping()">
                <h4 style="color: #f59e0b; margin: 0 0 10px 0;">üéØ Option 2: Manual Column Mapping</h4>
                <p style="margin: 0; font-size: 0.9em; color: #666;">Manually assign each column. Full control for custom formats.</p>
            </div>

            <!-- Option 3: Auto-Detection -->
            <div class="format-option" style="background: #dbeafe; border: 3px solid #667eea; padding: 20px; border-radius: 12px; cursor: pointer;" onclick="selectAutoDetection()">
                <h4 style="color: #667eea; margin: 0 0 10px 0;">ü§ñ Option 3: Smart Auto-Detection</h4>
                <p style="margin: 0; font-size: 0.9em; color: #666;">AI-powered detection analyzes your data automatically. Works for most formats.</p>
            </div>
        </div>

        <!-- Manual Column Mapping Modal Popup -->
        <div class="modal-overlay" id="columnMapperModal" style="display: none;">
            <div class="modal-content" style="max-width: 95%; width: 1400px;">
                <div class="modal-header">
                    <h3>üéØ Manual Column Mapping</h3>
                    <button class="modal-close" onclick="closeColumnMapperModal()">‚úï</button>
                </div>
                <div class="modal-body">
                    <p style="margin-bottom: 20px; color: #666; font-size: 0.95em;">
                        Click on each column header to assign its type. Preview shows first 10 rows of your data.
                    </p>

                    <!-- Data Preview Table -->
                    <div style="overflow-x: auto; overflow-y: visible; margin-bottom: 20px;">
                        <table id="dataPreviewTable" style="width: 100%; border-collapse: collapse; font-size: 0.9em;">
                            <!-- Will be populated dynamically -->
                        </table>
                    </div>

                    <!-- Type Selection Buttons -->
                    <div style="background: #f0f9ff; padding: 15px; border-radius: 10px; margin-bottom: 15px;">
                        <strong style="color: #667eea;">üìã Available Column Types:</strong>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin-top: 10px;">
                            <div style="padding: 10px; background: white; border-radius: 6px; border: 2px solid #10b981;">
                                <strong style="color: #10b981;">üá©üá™ German Word</strong>
                                <div style="font-size: 0.8em; color: #666; margin-top: 3px;">Main vocab shown immediately</div>
                            </div>
                            <div style="padding: 10px; background: white; border-radius: 6px; border: 2px solid #f59e0b;">
                                <strong style="color: #f59e0b;">üìù German Example</strong>
                                <div style="font-size: 0.8em; color: #666; margin-top: 3px;">Hidden until revealed</div>
                            </div>
                            <div style="padding: 10px; background: white; border-radius: 6px; border: 2px solid #10b981;">
                                <strong style="color: #10b981;">üá¨üáß English Word</strong>
                                <div style="font-size: 0.8em; color: #666; margin-top: 3px;">Main translation shown immediately</div>
                            </div>
                            <div style="padding: 10px; background: white; border-radius: 6px; border: 2px solid #f59e0b;">
                                <strong style="color: #f59e0b;">üìù English Example</strong>
                                <div style="font-size: 0.8em; color: #666; margin-top: 3px;">Hidden until revealed</div>
                            </div>
                            <div style="padding: 10px; background: white; border-radius: 6px; border: 2px solid #94a3b8;">
                                <strong style="color: #64748b;">üö´ Ignore</strong>
                                <div style="font-size: 0.8em; color: #666; margin-top: 3px;">Skip this column</div>
                            </div>
                        </div>
                    </div>

                    <div style="display: flex; gap: 10px; margin-top: 15px;">
                        <button class="control-btn" id="applyMappingBtnModal" style="flex: 1; background: #10b981;" onclick="processWithManualMapping()">
                            ‚úì Apply & Load Cards
                        </button>
                        <button class="control-btn" style="flex: 1; background: #94a3b8;" onclick="closeColumnMapperModal()">
                            ‚úï Cancel
                        </button>
                    </div>
                </div>
            </div>
        </div>


        <!-- Instructions (Collapsible) -->
        <div class="instructions" id="instructions" style="cursor: pointer;" onclick="this.style.display='none'">
            <h3>üìã CSV Format Instructions - v2.2 Enhanced (Click to hide):</h3>
            <p><strong>‚ú® NEW: Smart Format Detection!</strong> Auto-detects columns AND separators!</p>
            <p style="margin-top: 10px;"><strong>Supported Separators:</strong></p>
            <p>‚úÖ Comma (,) | ‚úÖ Semicolon (;) | ‚úÖ Pipe (|) | ‚úÖ Tab - All auto-detected!</p>
            <p style="margin-top: 10px;"><strong>Supported Formats:</strong></p>
            <p><strong>Basic:</strong> <code>German,English</code> or <code>English,German</code></p>
            <p><strong>Extended (NEW!):</strong> <code>German,Long German Text,English,Long English Text</code></p>
            <p style="margin-top: 10px;"><strong>Examples:</strong></p>
            <code>Hallo,Hello</code> (comma)<br>
            <code>Hallo;Hello</code> (semicolon - auto-detected!)<br>
            <code>Hallo|Ich sage hallo|Hello|I say hello</code> (pipe + extended)<br>
            <p style="margin-top: 10px;">‚úÖ Any separator | ‚úÖ Any column order | ‚úÖ Extended text supported</p>
        </div>

        <!-- Stats (Always Visible When File Loaded) -->
        <div class="stats" id="stats">
            <div class="stats-item">
                <span class="stats-value" id="learnedCount">0</span>
                <span>Learned</span>
            </div>
            <div class="stats-item">
                <span class="stats-value" id="remainingCount">0</span>
                <span>Remaining</span>
            </div>
            <div class="stats-item">
                <span class="stats-value" id="totalCount">0</span>
                <span>Total</span>
            </div>
        </div>

        <!-- Quick Actions (Always Visible When File Loaded) -->
        <div class="quick-actions" id="quickActions">
            <button class="quick-action-btn autoplay-btn" id="autoplayBtn">‚ñ∂ Auto-Play</button>
            <button class="quick-action-btn" id="shuffleBtn">üîÄ Shuffle</button>
            <button class="quick-action-btn" id="learnedBtn">‚úì Mark Learned</button>
            <button class="quick-action-btn" id="showLearnedBtn">üëÅ Unlearned Only</button>
            <button class="quick-action-btn" id="remapColumnsBtn" style="background: #f59e0b;">üéØ Remap Columns</button>
        </div>

        <!-- Settings Menu Toggle Button -->
        <button class="settings-toggle-btn" id="settingsToggleBtn">
            <span>‚öôÔ∏è Settings & Options</span>
            <span class="toggle-icon">‚ñº</span>
        </button>

        <!-- Settings Menu (Collapsible Accordion) -->
        <div class="settings-menu" id="settingsMenu">

            <!-- Voice & Speech Settings Accordion -->
            <div class="accordion-item">
                <div class="accordion-header" onclick="toggleAccordion(this)">
                    <span>üéôÔ∏è Voice & Speech Settings <span style="font-size: 0.8em; color: #888;">(v2.4 Enhanced)</span></span>
                    <span class="accordion-icon">‚ñº</span>
                </div>
                <div class="accordion-content">
                    <div style="background: #f0f8ff; padding: 10px; border-radius: 5px; margin-bottom: 15px; font-size: 0.9em; border-left: 3px solid #667eea;">
                        <strong>üîä = Google voices (recommended, highest quality)</strong><br>
                        <strong>üéôÔ∏è = Microsoft voices (high quality)</strong><br>
                        <span style="color: #666;">Tip: Google voices provide the most natural pronunciation for learning!</span>
                    </div>
                    <label>
                        <span><strong>German Voice:</strong></span>
                        <select id="germanVoiceSelect" style="width: 100%; padding: 8px; margin-top: 5px; border: 2px solid #667eea; border-radius: 5px; font-size: 14px;"></select>
                        <div id="germanVoiceInfo" style="font-size: 0.85em; color: #666; margin-top: 5px; font-style: italic;">Loading voices...</div>
                    </label>
                    <label style="margin-top: 15px;">
                        <span><strong>English Voice:</strong></span>
                        <select id="englishVoiceSelect" style="width: 100%; padding: 8px; margin-top: 5px; border: 2px solid #667eea; border-radius: 5px; font-size: 14px;"></select>
                        <div id="englishVoiceInfo" style="font-size: 0.85em; color: #666; margin-top: 5px; font-style: italic;">Loading voices...</div>
                    </label>
                    <label style="margin-top: 15px;">
                        <span>Speech Rate:</span>
                        <input type="range" id="speechRate" min="0.5" max="1.5" step="0.1" value="0.8">
                        <span class="delay-value" id="speechRateValue">0.8x</span>
                        <div style="font-size: 0.8em; color: #888; margin-top: 3px;">Slower (0.5x) ‚Üê ‚Üí Faster (1.5x)</div>
                    </label>
                    <label>
                        <span>Pitch:</span>
                        <input type="range" id="speechPitch" min="0.5" max="2" step="0.1" value="1.0">
                        <span class="delay-value" id="speechPitchValue">1.0</span>
                        <div style="font-size: 0.8em; color: #888; margin-top: 3px;">Lower (0.5) ‚Üê ‚Üí Higher (2.0)</div>
                    </label>
                </div>
            </div>

            <!-- Auto-Play Settings Accordion -->
            <div class="accordion-item">
                <div class="accordion-header" onclick="toggleAccordion(this)">
                    <span>‚ñ∂ Auto-Play Settings</span>
                    <span class="accordion-icon">‚ñº</span>
                </div>
                <div class="accordion-content">
                    <label>
                        <input type="checkbox" id="autoplayEnglish">
                        <span>Pronounce English translation (after German)</span>
                    </label>
                    <label>
                        <span>Delay between German & English:</span>
                        <input type="range" id="delayBetween" min="500" max="3000" step="100" value="1500">
                        <span class="delay-value" id="delayBetweenValue">1.5s</span>
                    </label>
                    <label>
                        <span>Delay before next card:</span>
                        <input type="range" id="delayNext" min="1000" max="5000" step="200" value="2500">
                        <span class="delay-value" id="delayNextValue">2.5s</span>
                    </label>
                    <hr style="border: 1px solid #e2e8f0; margin: 15px 0;">
                    <label>
                        <input type="checkbox" id="recordSession">
                        <span>üéôÔ∏è Record Session Audio</span>
                    </label>
                    <div id="recordingControls" style="display: none; margin: 15px 0; padding: 15px; background: #fee2e2; border-radius: 8px; border: 2px solid #ef4444;">
                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                            <span style="color: #dc2626; font-weight: 600;">‚è∫ Recording in progress...</span>
                            <span id="recordingTime" style="color: #dc2626; font-weight: bold;">0:00</span>
                        </div>
                        <button class="control-btn" id="stopRecordingBtn" style="background: #ef4444; width: 100%;">
                            ‚èπ Stop Recording
                        </button>
                    </div>
                    <div id="recordedAudioSection" style="display: none; margin: 15px 0; padding: 15px; background: #d1fae5; border-radius: 8px; border: 2px solid #10b981;">
                        <strong style="color: #065f46;">‚úì Recording Saved!</strong>
                        <div style="margin-top: 10px; display: flex; gap: 10px;">
                            <button class="control-btn" id="downloadRecordingBtn" style="background: #10b981; flex: 1;">
                                ‚¨á Download Audio
                            </button>
                            <button class="control-btn" id="playRecordingBtn" style="background: #3b82f6; flex: 1;">
                                ‚ñ∂ Play Recording
                            </button>
                        </div>
                        <audio id="recordedAudio" controls style="width: 100%; margin-top: 10px; display: none;"></audio>
                    </div>
                </div>
            </div>

            <!-- Advanced Features Accordion -->
            <div class="accordion-item">
                <div class="accordion-header" onclick="toggleAccordion(this)">
                    <span>üéØ Advanced Features</span>
                    <span class="accordion-icon">‚ñº</span>
                </div>
                <div class="accordion-content">
                    <label>
                        <input type="checkbox" id="loopMode">
                        <span>üîÅ Loop Mode - Restart automatically when finished</span>
                    </label>
                    <label>
                        <input type="checkbox" id="repeatMode">
                        <span>üó£Ô∏è Repeat Each Card:</span>
                        <select id="repeatCount" style="margin-left: 10px; padding: 4px;">
                            <option value="2">2 times</option>
                            <option value="3">3 times</option>
                            <option value="4">4 times</option>
                            <option value="5">5 times</option>
                        </select>
                    </label>
                    <label>
                        <input type="checkbox" id="studyTimer">
                        <span>‚è∞ Study Timer:</span>
                        <select id="studyDuration" style="margin-left: 10px; padding: 4px;">
                            <option value="5">5 minutes</option>
                            <option value="10">10 minutes</option>
                            <option value="15">15 minutes</option>
                            <option value="20">20 minutes</option>
                            <option value="30">30 minutes</option>
                            <option value="45">45 minutes</option>
                            <option value="60">60 minutes</option>
                        </select>
                    </label>
                    <label>
                        <input type="checkbox" id="sleepTimer">
                        <span>üìö Sleep Timer:</span>
                        <select id="sleepDuration" style="margin-left: 10px; padding: 4px;">
                            <option value="10">10 minutes</option>
                            <option value="15">15 minutes</option>
                            <option value="20">20 minutes</option>
                            <option value="30">30 minutes</option>
                            <option value="45">45 minutes</option>
                        </select>
                    </label>
                </div>
            </div>

            <!-- Display Options Accordion -->
            <div class="accordion-item">
                <div class="accordion-header" onclick="toggleAccordion(this)">
                    <span>üëÅÔ∏è Display Options</span>
                    <span class="accordion-icon">‚ñº</span>
                </div>
                <div class="accordion-content">
                    <label style="display: flex; align-items: center; gap: 10px; margin: 10px 0;">
                        <input type="checkbox" id="alwaysShowMeanings">
                        <span>Always show English meanings</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 10px; margin: 10px 0;">
                        <input type="checkbox" id="readExtendedContent">
                        <span>üìñ Read Extended Examples/Sentences in Auto-Play</span>
                    </label>
                    <button class="control-btn" id="focusModeBtn" style="width: 100%; margin-top: 10px; background: #6366f1;">
                        üéØ Enter Focus Mode
                    </button>
                    <button class="control-btn" id="resetBtn" style="width: 100%; margin-top: 10px; background: #ef4444;">
                        ‚Ü∫ Reset All Progress
                    </button>
                </div>
            </div>

        </div>

        <!-- Timer Display (Shows During Auto-Play) -->
        <div class="timer-display" id="timerDisplay">
            <span id="timerText">Time Remaining: 00:00</span>
        </div>

        <!-- Session Stats (Shows During Auto-Play) -->
        <div class="session-stats" id="sessionStats">
            <h4>üìä Session Statistics</h4>
            <div class="stat-row">
                <span class="stat-label">Cards Reviewed:</span>
                <span class="stat-value" id="cardsReviewed">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Time Studying:</span>
                <span class="stat-value" id="timeStudying">00:00</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Cards per Minute:</span>
                <span class="stat-value" id="cardsPerMinute">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Session Started:</span>
                <span class="stat-value" id="sessionStart">--:--</span>
            </div>
        </div>

        <div class="flashcard-container" id="flashcardContainer">
            <div class="flashcard" id="flashcard">
                <div class="card-german-section">
                    <button class="audio-btn" id="audioBtn" title="Pronounce German word">üîä</button>
                    <div class="learned-badge" id="learnedBadge" style="display: none;">‚úì Learned</div>
                    <div class="card-label">German (Deutsch) üá©üá™</div>
                    <div class="card-content" id="germanWord"></div>
                    <div class="review-info" id="reviewInfo"></div>
                    <hr class="card-divider">
                    <button class="reveal-btn" id="revealBtn">üëÅ Show English Meaning</button>
                </div>
                <div class="card-english-section" id="englishSection">
                    <div class="card-label">English Translation üá¨üáß</div>
                    <div class="card-content" id="englishWord"></div>
                    <div class="card-detail" id="detailBack"></div>
                    <button class="audio-btn-english" id="audioBtnEnglish" title="Pronounce English word">üîä</button>
                </div>
            </div>
            <div class="hint">üëÜ Click "Show English Meaning" or Space to reveal | üîä P for German | E for English pronunciation</div>
        </div>

        <div class="navigation" id="navigation">
            <button class="nav-button" id="prevBtn">‚Üê Previous</button>
            <div class="progress" id="progress">1 / 1</div>
            <button class="nav-button" id="nextBtn">Next ‚Üí</button>
        </div>
    </div>

    <script>
        let flashcards = [];
        let currentIndex = 0;
        let showOnlyUnlearned = false;
        let filteredCards = [];
        let currentFileName = '';
        let alwaysShowMeanings = false;
        let readExtendedContent = false; // New: toggle for reading extended examples/sentences

        // Column mapping variables
        let rawFileData = null;
        let detectedSeparator = ',';
        let columnMapping = null; // null = auto-detect, or {col0: 'german', col1: 'germanExtended', ...}

        // Category management
        let categories = {};
        let fileCategories = {};
        let currentFileCategory = { category: 'Default', subcategory: '' };

        // Auto-play variables
        let isAutoPlaying = false;
        let autoplayTimeout = null;
        let autoplayEnglishEnabled = false;
        let delayBetweenLangs = 1500; // milliseconds
        let delayBeforeNext = 2500; // milliseconds

        // Advanced feature variables
        let loopModeEnabled = false;
        let repeatModeEnabled = false;
        let repeatCount = 2;
        let currentRepeat = 0;
        let studyTimerEnabled = false;
        let sleepTimerEnabled = false;
        let timerInterval = null;
        let timerEndTime = null;

        // Session stats variables
        let sessionStartTime = null;
        let cardsReviewedCount = 0;
        let statsInterval = null;

        // Recording variables
        let mediaRecorder = null;
        let recordedChunks = [];
        let recordingStartTime = null;
        let recordingTimerInterval = null;
        let recordedAudioBlob = null;
        let isRecording = false;

        // Speech synthesis for audio pronunciation
        const synth = window.speechSynthesis;
        let germanVoice = null;
        let englishVoice = null;
        let allVoices = [];
        let speechRate = 0.8;
        let speechPitch = 1.0;

        // Load voices
        function loadVoices() {
            allVoices = synth.getVoices();

            // Filter and sort German voices (prioritize Google voices and de-DE)
            let germanVoices = allVoices.filter(voice => voice.lang.startsWith('de'));
            germanVoices.sort((a, b) => {
                // Priority order: Google de-DE > Google other > Microsoft de-DE > Others
                const aIsGoogle = a.name.toLowerCase().includes('google');
                const bIsGoogle = b.name.toLowerCase().includes('google');
                const aIsDeDE = a.lang === 'de-DE';
                const bIsDeDE = b.lang === 'de-DE';

                if (aIsGoogle && !bIsGoogle) return -1;
                if (!aIsGoogle && bIsGoogle) return 1;
                if (aIsDeDE && !bIsDeDE) return -1;
                if (!aIsDeDE && bIsDeDE) return 1;
                return 0;
            });

            // Filter and sort English voices (prioritize Google US, then UK, then others)
            let englishVoices = allVoices.filter(voice => voice.lang.startsWith('en'));
            englishVoices.sort((a, b) => {
                // Priority: Google en-US > Google en-GB > Microsoft en-US > Others
                const aIsGoogle = a.name.toLowerCase().includes('google');
                const bIsGoogle = b.name.toLowerCase().includes('google');
                const aIsUS = a.lang === 'en-US';
                const bIsUS = b.lang === 'en-US';
                const aIsGB = a.lang === 'en-GB';
                const bIsGB = b.lang === 'en-GB';

                if (aIsGoogle && !bIsGoogle) return -1;
                if (!aIsGoogle && bIsGoogle) return 1;
                if (aIsUS && !bIsUS) return -1;
                if (!aIsUS && bIsUS) return 1;
                if (aIsGB && !bIsGB) return -1;
                if (!aIsGB && bIsGB) return 1;
                return 0;
            });

            // Set default voices (prefer Google voices)
            germanVoice = germanVoices.find(v => v.name.toLowerCase().includes('google') && v.lang === 'de-DE')
                || germanVoices.find(v => v.lang === 'de-DE')
                || germanVoices[0]
                || allVoices[0];

            englishVoice = englishVoices.find(v => v.name.toLowerCase().includes('google') && v.lang === 'en-US')
                || englishVoices.find(v => v.lang === 'en-US')
                || englishVoices[0]
                || allVoices[0];

            // Populate German voice dropdown with enhanced labels
            const germanSelect = document.getElementById('germanVoiceSelect');
            germanSelect.innerHTML = '';
            germanVoices.forEach((voice, index) => {
                const option = document.createElement('option');
                option.value = index;

                // Enhanced label with provider and quality indicators
                let label = voice.name;
                if (voice.name.toLowerCase().includes('google')) {
                    label = `üîä ${voice.name} (${voice.lang})`;
                } else if (voice.name.toLowerCase().includes('microsoft')) {
                    label = `üéôÔ∏è ${voice.name} (${voice.lang})`;
                } else {
                    label = `${voice.name} (${voice.lang})`;
                }

                // Add quality/region indicators
                if (voice.lang === 'de-DE') {
                    label += ' - German (Germany)';
                } else if (voice.lang === 'de-AT') {
                    label += ' - German (Austria)';
                } else if (voice.lang === 'de-CH') {
                    label += ' - German (Switzerland)';
                }

                option.textContent = label;

                // Mark default as selected
                if (voice === germanVoice) {
                    option.selected = true;
                }

                germanSelect.appendChild(option);
            });

            // Populate English voice dropdown with enhanced labels
            const englishSelect = document.getElementById('englishVoiceSelect');
            englishSelect.innerHTML = '';
            englishVoices.forEach((voice, index) => {
                const option = document.createElement('option');
                option.value = index;

                // Enhanced label with provider and quality indicators
                let label = voice.name;
                if (voice.name.toLowerCase().includes('google')) {
                    label = `üîä ${voice.name} (${voice.lang})`;
                } else if (voice.name.toLowerCase().includes('microsoft')) {
                    label = `üéôÔ∏è ${voice.name} (${voice.lang})`;
                } else {
                    label = `${voice.name} (${voice.lang})`;
                }

                // Add region indicators
                if (voice.lang === 'en-US') {
                    label += ' - English (United States)';
                } else if (voice.lang === 'en-GB') {
                    label += ' - English (United Kingdom)';
                } else if (voice.lang === 'en-AU') {
                    label += ' - English (Australia)';
                } else if (voice.lang === 'en-IN') {
                    label += ' - English (India)';
                } else if (voice.lang === 'en-CA') {
                    label += ' - English (Canada)';
                } else if (voice.lang === 'en-NZ') {
                    label += ' - English (New Zealand)';
                } else if (voice.lang === 'en-ZA') {
                    label += ' - English (South Africa)';
                } else if (voice.lang === 'en-IE') {
                    label += ' - English (Ireland)';
                }

                option.textContent = label;

                // Mark default as selected
                if (voice === englishVoice) {
                    option.selected = true;
                }

                englishSelect.appendChild(option);
            });

            // Store filtered voices for easy access
            germanSelect.dataset.voices = JSON.stringify(germanVoices.map(v => v.name));
            englishSelect.dataset.voices = JSON.stringify(englishVoices.map(v => v.name));

            // Update voice info displays
            updateVoiceInfo('german', germanVoice);
            updateVoiceInfo('english', englishVoice);

            // Log default voices for debugging
            console.log('‚úÖ v2.4 Voice System Loaded');
            console.log('Default German Voice:', germanVoice ? germanVoice.name : 'None');
            console.log('Default English Voice:', englishVoice ? englishVoice.name : 'None');
            console.log('Total German voices available:', germanVoices.length);
            console.log('Total English voices available:', englishVoices.length);
        }

        // Update voice info display
        function updateVoiceInfo(language, voice) {
            const infoElement = document.getElementById(language + 'VoiceInfo');
            if (!voice || !infoElement) return;

            let info = '';
            const isGoogle = voice.name.toLowerCase().includes('google');
            const isMicrosoft = voice.name.toLowerCase().includes('microsoft');

            if (isGoogle) {
                info = 'üîä <strong>Google Voice</strong> - Premium quality, natural pronunciation (Recommended for learning)';
            } else if (isMicrosoft) {
                info = 'üéôÔ∏è <strong>Microsoft Voice</strong> - High quality, clear enunciation';
            } else {
                info = 'üì¢ <strong>System Voice</strong> - Standard quality';
            }

            // Add voice details
            info += `<br><span style="color: #888;">Voice: ${voice.name} | Language: ${voice.lang}</span>`;

            infoElement.innerHTML = info;
        }

        // Load voices on page load
        if (synth.onvoiceschanged !== undefined) {
            synth.onvoiceschanged = loadVoices;
        }
        loadVoices();

        // Category Management Functions
        function loadCategories() {
            const saved = localStorage.getItem('flashcard_categories');
            if (saved) {
                categories = JSON.parse(saved);
            } else {
                categories = { 'Default': [] };
            }

            const savedFiles = localStorage.getItem('flashcard_file_categories');
            if (savedFiles) {
                fileCategories = JSON.parse(savedFiles);
            }

            updateCategoryDropdowns();
            renderCategoryList();
        }

        function saveCategories() {
            localStorage.setItem('flashcard_categories', JSON.stringify(categories));
            localStorage.setItem('flashcard_file_categories', JSON.stringify(fileCategories));
        }

        function createCategory() {
            const name = document.getElementById('newCategoryName').value.trim();
            if (!name) {
                alert('Please enter a category name');
                return;
            }
            if (categories[name]) {
                alert('Category already exists!');
                return;
            }

            categories[name] = [];
            saveCategories();
            updateCategoryDropdowns();
            renderCategoryList();
            renderCategoryBrowser();
            document.getElementById('newCategoryName').value = '';
            alert(`Category "${name}" created!`);
        }

        function createSubcategory() {
            const parent = document.getElementById('parentCategorySelect').value;
            const name = document.getElementById('newSubcategoryName').value.trim();

            if (!name) {
                alert('Please enter a subcategory name');
                return;
            }

            if (!categories[parent]) {
                alert('Parent category not found!');
                return;
            }

            if (categories[parent].includes(name)) {
                alert('Subcategory already exists!');
                return;
            }

            categories[parent].push(name);
            saveCategories();
            updateCategoryDropdowns();
            renderCategoryList();
            renderCategoryBrowser();
            document.getElementById('newSubcategoryName').value = '';
            alert(`Subcategory "${name}" added to "${parent}"!`);
        }

        function assignCategory() {
            if (!currentFileName) {
                alert('No file loaded!');
                return;
            }

            const category = document.getElementById('categorySelect').value;
            const subcategory = document.getElementById('subcategorySelect').value;

            fileCategories[currentFileName] = { category, subcategory };
            currentFileCategory = { category, subcategory };

            saveCategories();
            updateCurrentFileDisplay();
            renderCategoryBrowser();

            const subText = subcategory ? ` > ${subcategory}` : '';
            alert(`File mapped to: ${category}${subText}`);
        }

        function updateCategoryDropdowns() {
            const categorySelect = document.getElementById('categorySelect');
            const parentSelect = document.getElementById('parentCategorySelect');
            const subcategorySelect = document.getElementById('subcategorySelect');

            // Update category selects
            [categorySelect, parentSelect].forEach(select => {
                const current = select.value;
                select.innerHTML = '';
                Object.keys(categories).forEach(cat => {
                    const option = document.createElement('option');
                    option.value = cat;
                    option.textContent = cat;
                    select.appendChild(option);
                });
                if (current && categories[current]) {
                    select.value = current;
                }
            });

            // Update subcategory select
            updateSubcategoryDropdown();
        }

        function updateSubcategoryDropdown() {
            const category = document.getElementById('categorySelect').value;
            const subcategorySelect = document.getElementById('subcategorySelect');

            subcategorySelect.innerHTML = '<option value="">No Subcategory</option>';

            if (categories[category]) {
                categories[category].forEach(sub => {
                    const option = document.createElement('option');
                    option.value = sub;
                    option.textContent = sub;
                    subcategorySelect.appendChild(option);
                });
            }
        }

        function renderCategoryList() {
            const listDiv = document.getElementById('categoryList');
            listDiv.innerHTML = '';

            Object.keys(categories).forEach(cat => {
                const catDiv = document.createElement('div');
                catDiv.className = 'category-item';

                const catInfo = document.createElement('span');
                catInfo.innerHTML = `üìÅ <strong>${cat}</strong>`;

                const actions = document.createElement('div');
                if (cat !== 'Default') {
                    const deleteBtn = document.createElement('button');
                    deleteBtn.textContent = '‚úï';
                    deleteBtn.className = 'btn-small';
                    deleteBtn.style.background = '#ef4444';
                    deleteBtn.style.color = 'white';
                    deleteBtn.style.border = 'none';
                    deleteBtn.style.borderRadius = '4px';
                    deleteBtn.style.cursor = 'pointer';
                    deleteBtn.onclick = () => deleteCategory(cat);
                    actions.appendChild(deleteBtn);
                }

                catDiv.appendChild(catInfo);
                catDiv.appendChild(actions);
                listDiv.appendChild(catDiv);

                // Add subcategories
                if (categories[cat] && categories[cat].length > 0) {
                    categories[cat].forEach(sub => {
                        const subDiv = document.createElement('div');
                        subDiv.className = 'category-item subcategory-item';

                        const subInfo = document.createElement('span');
                        subInfo.innerHTML = `‚îî‚îÄ ${sub}`;

                        const subActions = document.createElement('div');
                        const deleteSubBtn = document.createElement('button');
                        deleteSubBtn.textContent = '‚úï';
                        deleteSubBtn.className = 'btn-small';
                        deleteSubBtn.style.background = '#f59e0b';
                        deleteSubBtn.style.color = 'white';
                        deleteSubBtn.style.border = 'none';
                        deleteSubBtn.style.borderRadius = '4px';
                        deleteSubBtn.style.cursor = 'pointer';
                        deleteSubBtn.onclick = () => deleteSubcategory(cat, sub);
                        subActions.appendChild(deleteSubBtn);

                        subDiv.appendChild(subInfo);
                        subDiv.appendChild(subActions);
                        listDiv.appendChild(subDiv);
                    });
                }
            });
        }

        function deleteCategory(category) {
            if (category === 'Default') {
                alert('Cannot delete Default category!');
                return;
            }

            if (!confirm(`Delete category "${category}" and all its subcategories?`)) {
                return;
            }

            delete categories[category];

            // Reassign files to Default
            Object.keys(fileCategories).forEach(file => {
                if (fileCategories[file].category === category) {
                    fileCategories[file] = { category: 'Default', subcategory: '' };
                }
            });

            saveCategories();
            updateCategoryDropdowns();
            renderCategoryList();
            alert(`Category "${category}" deleted!`);
        }

        function deleteSubcategory(category, subcategory) {
            if (!confirm(`Delete subcategory "${subcategory}"?`)) {
                return;
            }

            const index = categories[category].indexOf(subcategory);
            if (index > -1) {
                categories[category].splice(index, 1);
            }

            // Reassign files
            Object.keys(fileCategories).forEach(file => {
                if (fileCategories[file].category === category &&
                    fileCategories[file].subcategory === subcategory) {
                    fileCategories[file].subcategory = '';
                }
            });

            saveCategories();
            updateCategoryDropdowns();
            renderCategoryList();
            alert(`Subcategory "${subcategory}" deleted!`);
        }

        function updateCurrentFileDisplay() {
            if (currentFileName) {
                document.getElementById('currentFileDisplay').textContent = currentFileName;

                const cat = currentFileCategory.category || 'Default';
                const sub = currentFileCategory.subcategory;
                const badgeText = sub ? `${cat} > ${sub}` : cat;

                document.getElementById('currentCategoryBadge').textContent = badgeText;
            }
        }

        function filterByCategory() {
            // TODO: Implement filtering by category
            alert('Filter by category feature coming soon!');
        }

        // Category select change handler
        document.getElementById('categorySelect').addEventListener('change', updateSubcategoryDropdown);

        // Category Management Toggle Button Handler
        document.getElementById('categoryMgmtToggleBtn').addEventListener('click', function() {
            const section = document.getElementById('categoryManagerSection');
            const isVisible = section.style.display === 'block';

            if (isVisible) {
                section.style.display = 'none';
                this.classList.remove('active');
            } else {
                section.style.display = 'block';
                this.classList.add('active');
            }
        });

        // Intelligent Category Suggestion System
        let suggestedCategory = null;
        let suggestedSubcategory = null;

        function suggestCategoryFromFile(fileName, fileContent = '') {
            // Extract category hints from filename
            const nameLower = fileName.toLowerCase().replace(/\.(csv|txt|tsv)$/i, '');

            // IMPORTANT: Check for detailed level patterns BEFORE splitting (to preserve A1.1, B2.3, etc.)
            let detectedDetailedLevel = null;
            const detailedLevelMatch = nameLower.match(/([abc][12])\.(\d+)/i);
            if (detailedLevelMatch) {
                const level = detailedLevelMatch[1].toUpperCase();
                const sublevel = detailedLevelMatch[2];
                detectedDetailedLevel = `${level}.${sublevel}`;
                console.log('üéØ Pre-split: Found detailed level:', detectedDetailedLevel);
            }

            // Split filename by common separators to analyze parts
            const nameParts = nameLower.split(/[_\-\s.]+/);

            // Common patterns in filenames
            const patterns = {
                // Language levels - enhanced to catch more variations
                a1: /\b(a1(?!\.\d)|beginner|anf√§nger|elementary)\b/i,
                a2: /\b(a2(?!\.\d)|elementary|grundstufe)\b/i,
                b1: /\b(b1(?!\.\d)|intermediate|mittelstufe)\b/i,
                b2: /\b(b2(?!\.\d)|upper[_\-]?intermediate|oberstufe)\b/i,
                c1: /\b(c1(?!\.\d)|advanced|fortgeschritten)\b/i,
                c2: /\b(c2(?!\.\d)|proficient|sehr[_\-]?fortgeschritten)\b/i,

                // Subject categories
                business: /\b(business|gesch√§ft|wirtschaft|beruf|office|meeting)\b/i,
                travel: /\b(travel|reise|urlaub|tourism|vacation|hotel|airport)\b/i,
                food: /\b(food|essen|cuisine|k√ºche|restaurant|cooking|meal)\b/i,
                medical: /\b(medical|medizin|health|gesundheit|doctor|arzt|hospital|clinic)\b/i,
                technology: /\b(tech|technology|computer|it|software|programming|digital)\b/i,
                everyday: /\b(everyday|daily|alltag|basic|common|routine)\b/i,
                family: /\b(family|familie|home|haus|zuhause|parents|kinder)\b/i,
                shopping: /\b(shopping|einkaufen|store|laden|market|kaufen)\b/i,
                work: /\b(work|arbeit|job|career|karriere|office)\b/i,

                // Content types
                verbs: /\b(verb|verben|action|tun|doing)\b/i,
                nouns: /\b(noun|nomen|substantiv|things|dinge|objects)\b/i,
                adjectives: /\b(adjective|adjektiv|beschreibung|describing)\b/i,
                phrases: /\b(phrase|satz|expression|redewendung|sentence|saying)\b/i,
                grammar: /\b(grammar|grammatik|rules|regeln|structure)\b/i,
                vocabulary: /\b(vocab|vokabel|wort|word|w√∂rter)\b/i,

                // Languages
                german: /\b(german|deutsch|de)\b/i,
                english: /\b(english|englisch|en)\b/i
            };

            let category = null;
            let subcategory = null;

            // Priority 1: Detect main category (theme/subject)
            if (patterns.business.test(nameLower)) {
                category = 'Business';
            } else if (patterns.travel.test(nameLower)) {
                category = 'Travel';
            } else if (patterns.medical.test(nameLower)) {
                category = 'Medical';
            } else if (patterns.technology.test(nameLower)) {
                category = 'Technology';
            } else if (patterns.food.test(nameLower)) {
                category = 'Food';
            } else if (patterns.family.test(nameLower)) {
                category = 'Family';
            } else if (patterns.shopping.test(nameLower)) {
                category = 'Shopping';
            } else if (patterns.work.test(nameLower)) {
                category = 'Work';
            } else if (patterns.everyday.test(nameLower)) {
                category = 'Everyday';
            } else if (patterns.german.test(nameLower)) {
                category = 'German';
            }

            // Priority 2: Detect subcategory (level or content type)
            // First use the pre-split detailed level if found (this preserves A1.1, B2.3, etc.)
            if (detectedDetailedLevel) {
                subcategory = detectedDetailedLevel;
                console.log('‚úÖ Using pre-split detailed level:', subcategory);
            }
            // Then check for basic language levels
            else if (patterns.a1.test(nameLower)) {
                subcategory = 'A1';
            } else if (patterns.a2.test(nameLower)) {
                subcategory = 'A2';
            } else if (patterns.b1.test(nameLower)) {
                subcategory = 'B1';
            } else if (patterns.b2.test(nameLower)) {
                subcategory = 'B2';
            } else if (patterns.c1.test(nameLower)) {
                subcategory = 'C1';
            } else if (patterns.c2.test(nameLower)) {
                subcategory = 'C2';
            }
            // Then check for numbered subcategories (e.g., Lesson1, Unit2, Chapter3)
            else {
                const numberedMatch = nameLower.match(/\b(lesson|unit|chapter|lektion|einheit|kapitel)[_\-\s]?(\d+)\b/i);
                if (numberedMatch) {
                    const type = numberedMatch[1].charAt(0).toUpperCase() + numberedMatch[1].slice(1);
                    const number = numberedMatch[2];
                    subcategory = `${type} ${number}`;
                    console.log('Detected numbered subcategory:', subcategory);
                }
                // Then content types
                else if (patterns.verbs.test(nameLower)) {
                    subcategory = 'Verbs';
                } else if (patterns.nouns.test(nameLower)) {
                    subcategory = 'Nouns';
                } else if (patterns.adjectives.test(nameLower)) {
                    subcategory = 'Adjectives';
                } else if (patterns.phrases.test(nameLower)) {
                    subcategory = 'Phrases';
                } else if (patterns.grammar.test(nameLower)) {
                    subcategory = 'Grammar';
                } else if (patterns.vocabulary.test(nameLower)) {
                    subcategory = 'Vocabulary';
                }
                // Finally, check for simple numbers at the end (e.g., vocab1, test2)
                else {
                    const simpleNumberMatch = nameLower.match(/(\d+)$/);
                    if (simpleNumberMatch) {
                        subcategory = `Part ${simpleNumberMatch[1]}`;
                        console.log('Detected simple numbered part:', subcategory);
                    }
                }
            }

            // Analyze file content for additional hints (first 1000 chars)
            if (fileContent && fileContent.length > 100) {
                const contentSample = fileContent.substring(0, 1000).toLowerCase();

                // If no category detected from filename, try content analysis
                if (!category) {
                    const germanWordCount = (contentSample.match(/\b(der|die|das|ich|du|er|sie|wir|und|oder|ist|sind|haben|sein)\b/g) || []).length;
                    if (germanWordCount > 5) {
                        category = 'German';
                    }
                }

                // If still no category, create one from first meaningful part of filename
                if (!category && nameParts.length > 0) {
                    // Take first meaningful part (not numbers or single letters)
                    const meaningfulPart = nameParts.find(part => part.length > 2 && !/^\d+$/.test(part));
                    if (meaningfulPart) {
                        // Capitalize first letter
                        category = meaningfulPart.charAt(0).toUpperCase() + meaningfulPart.slice(1);
                    }
                }
            }

            // Fallback: If still no category, use filename base as category
            if (!category) {
                const baseName = nameParts[0] || 'Vocabulary';
                category = baseName.charAt(0).toUpperCase() + baseName.slice(1);
            }

            // Smart subcategory fallback: If no subcategory detected, try to create one from filename parts
            if (!subcategory && nameParts.length > 1) {
                // Look for the second meaningful part that's not the category
                const categoryLower = category.toLowerCase();
                const potentialSubcat = nameParts.find((part, idx) => {
                    return idx > 0 &&
                           part.length > 1 &&
                           part !== categoryLower &&
                           part !== 'csv' &&
                           part !== 'txt' &&
                           !part.match(/^\d+$/); // Skip pure numbers
                });

                if (potentialSubcat) {
                    // Capitalize first letter
                    subcategory = potentialSubcat.charAt(0).toUpperCase() + potentialSubcat.slice(1);
                    console.log('  ‚ú® Created subcategory from filename parts:', subcategory);
                }
            }

            console.log('üîç Smart Detection Analysis:');
            console.log('  üìÅ Filename:', fileName);
            console.log('  üìÑ Lowercase name:', nameLower);
            console.log('  üìÇ Detected Category:', category || 'None');
            console.log('  üìã Detected Subcategory:', subcategory || 'None');
            console.log('  üî§ Name parts:', nameParts);

            // Additional debugging for subcategory detection
            console.log('  üîç Subcategory Detection Tests:');
            console.log('    - Detailed level (A1.1):', nameLower.match(/\b([abc][12])\.(\d+)\b/i));
            console.log('    - Basic A1:', patterns.a1.test(nameLower));
            console.log('    - Basic A2:', patterns.a2.test(nameLower));
            console.log('    - Verbs:', patterns.verbs.test(nameLower));
            console.log('    - Simple number:', nameLower.match(/(\d+)$/));

            return { category, subcategory };
        }

        function showCategorySuggestion(category, subcategory) {
            console.log('üéØ showCategorySuggestion CALLED with:', category, subcategory);

            const section = document.getElementById('suggestedCategorySection');
            const categoryInput = document.getElementById('suggestedCategoryInput');
            const subcategoryInput = document.getElementById('suggestedSubcategoryInput');

            if (!section || !categoryInput || !subcategoryInput) {
                console.error('‚ùå Required elements not found for category suggestion');
                return;
            }

            suggestedCategory = category;
            suggestedSubcategory = subcategory;

            // If no category detected, use Default
            if (!category) {
                console.log('No category detected, using Default');
                category = 'Default';
            }

            // Populate the editable input fields with suggestions
            categoryInput.value = category || '';
            subcategoryInput.value = subcategory || '';

            console.log('üí° Showing suggestion box with:', category, subcategory);

            // Show the suggestion section
            section.style.display = 'block';

            console.log('‚úÖ Suggestion box displayed prominently');

            // Scroll to suggestion box smoothly
            setTimeout(() => {
                try {
                    section.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    categoryInput.focus();
                    categoryInput.select();
                } catch(e) {
                    console.error('Scroll/focus error:', e);
                }
            }, 300);
        }

        // Function to hide category suggestion
        function hideCategorySuggestion() {
            const section = document.getElementById('suggestedCategorySection');
            if (section) {
                section.style.display = 'none';
                console.log('‚úÖ Category suggestion box hidden');
            }
        }

        function autoApplyCategory(category, subcategory) {
            if (!category) return;

            // Create category if it doesn't exist
            if (!categories[category]) {
                categories[category] = [];
                console.log('Auto-created category:', category);
            }

            // Create subcategory if suggested and doesn't exist
            if (subcategory && !categories[category].includes(subcategory)) {
                categories[category].push(subcategory);
                console.log('Auto-created subcategory:', subcategory);
            }

            // Save and update UI
            saveCategories();
            updateCategoryDropdowns();
            renderCategoryList();

            // Assign current file to detected category AUTOMATICALLY
            if (currentFileName) {
                fileCategories[currentFileName] = {
                    category: category,
                    subcategory: subcategory || ''
                };
                currentFileCategory = fileCategories[currentFileName];
                saveCategories();
                updateCurrentFileDisplay();
            }

            // Update dropdowns to show selected values
            document.getElementById('categorySelect').value = category;
            updateSubcategoryDropdown();
            if (subcategory) {
                document.getElementById('subcategorySelect').value = subcategory;
            }

            // Render category browser
            renderCategoryBrowser();
        }

        function applySuggestedCategory() {
            // Read values from input fields (user might have edited them)
            const categoryInput = document.getElementById('suggestedCategoryInput');
            const subcategoryInput = document.getElementById('suggestedSubcategoryInput');

            const category = categoryInput.value.trim();
            const subcategory = subcategoryInput.value.trim();

            if (!category) {
                alert('Please enter a category name!');
                categoryInput.focus();
                return;
            }

            console.log('‚úÖ User approved category:', category, subcategory);

            // Create category if it doesn't exist
            if (!categories[category]) {
                categories[category] = [];
                console.log('Created new category:', category);
            }

            // Create subcategory if provided and doesn't exist
            if (subcategory && !categories[category].includes(subcategory)) {
                categories[category].push(subcategory);
                console.log('Created new subcategory:', subcategory);
            }

            // Save and update UI
            saveCategories();
            updateCategoryDropdowns();
            renderCategoryList();

            // Assign current file to approved category
            if (currentFileName) {
                fileCategories[currentFileName] = {
                    category: category,
                    subcategory: subcategory || ''
                };
                currentFileCategory = fileCategories[currentFileName];
                saveCategories(); // Save category mappings
                updateCurrentFileDisplay();

                console.log('‚úÖ File category assignment complete:', currentFileName, '‚Üí', category, subcategory);
                console.log('üì¶ Flashcard data already in localStorage (saved during parsing)');
            }

            // Update dropdowns to show selected values
            document.getElementById('categorySelect').value = category;
            updateSubcategoryDropdown();
            if (subcategory) {
                document.getElementById('subcategorySelect').value = subcategory;
            }

            // Hide suggestion section
            document.getElementById('suggestedCategorySection').style.display = 'none';

            // Render category browser
            renderCategoryBrowser();

            // Show success message
            const subText = subcategory ? ` ‚Üí ${subcategory}` : '';
            alert(`‚úì Success! File assigned to:\nüìÅ ${category}${subText}\n\nüíæ Vocabulary saved and ready to practice!`);
        }

        function rejectSuggestion() {
            console.log('‚ùå User rejected suggestion, using Default');

            // Assign to Default category
            if (currentFileName) {
                fileCategories[currentFileName] = {
                    category: 'Default',
                    subcategory: ''
                };
                currentFileCategory = fileCategories[currentFileName];
                saveCategories(); // Save category mappings
                updateCurrentFileDisplay();

                console.log('‚úÖ File assigned to Default category:', currentFileName);
                console.log('üì¶ Flashcard data already in localStorage (saved during parsing)');
            }

            // Update dropdowns
            document.getElementById('categorySelect').value = 'Default';
            updateSubcategoryDropdown();

            // Hide suggestion section
            document.getElementById('suggestedCategorySection').style.display = 'none';

            // Render category browser
            renderCategoryBrowser();

            alert('‚úì File assigned to Default category\n\nüíæ Vocabulary saved and ready to practice!');
        }

        // Category Browser Functions
        function renderCategoryBrowser() {
            const browserList = document.getElementById('categoryBrowserList');
            const noMessage = document.getElementById('noCategoriesMessage');

            // Get all files organized by category
            const categoryFiles = {};

            Object.keys(fileCategories).forEach(fileName => {
                const cat = fileCategories[fileName].category || 'Default';
                const subcat = fileCategories[fileName].subcategory || '';

                if (!categoryFiles[cat]) {
                    categoryFiles[cat] = {};
                }

                if (subcat) {
                    if (!categoryFiles[cat][subcat]) {
                        categoryFiles[cat][subcat] = [];
                    }
                    categoryFiles[cat][subcat].push(fileName);
                } else {
                    if (!categoryFiles[cat]['_root']) {
                        categoryFiles[cat]['_root'] = [];
                    }
                    categoryFiles[cat]['_root'].push(fileName);
                }
            });

            // Check if we have any categories with files
            const hasCategories = Object.keys(categoryFiles).length > 0;

            if (!hasCategories) {
                browserList.innerHTML = '';
                noMessage.style.display = 'block';
                return;
            }

            noMessage.style.display = 'none';
            browserList.innerHTML = '';

            // Render each category
            Object.keys(categoryFiles).sort().forEach(category => {
                const categoryCard = document.createElement('div');
                categoryCard.style.cssText = `
                    background: white;
                    border: 2px solid #667eea;
                    border-radius: 10px;
                    padding: 15px;
                    cursor: pointer;
                    transition: all 0.3s;
                    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                `;

                categoryCard.addEventListener('mouseenter', function() {
                    this.style.transform = 'translateY(-3px)';
                    this.style.boxShadow = '0 4px 12px rgba(102, 126, 234, 0.3)';
                });

                categoryCard.addEventListener('mouseleave', function() {
                    this.style.transform = 'translateY(0)';
                    this.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
                });

                // Count total files in this category
                let fileCount = 0;
                Object.keys(categoryFiles[category]).forEach(subcat => {
                    fileCount += categoryFiles[category][subcat].length;
                });

                // Category header
                const header = document.createElement('div');
                header.style.cssText = 'display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;';
                header.innerHTML = `
                    <div>
                        <div style="font-size: 1.3em; font-weight: 600; color: #667eea;">üìÅ ${category}</div>
                        <div style="font-size: 0.8em; color: #999; margin-top: 3px;">${fileCount} file${fileCount !== 1 ? 's' : ''}</div>
                    </div>
                `;

                categoryCard.appendChild(header);

                // Subcategories list
                const subcatList = document.createElement('div');
                subcatList.style.cssText = 'margin-top: 10px; padding-top: 10px; border-top: 1px solid #e0e0e0; font-size: 0.85em;';

                const subcats = Object.keys(categoryFiles[category]).filter(s => s !== '_root').sort();
                if (subcats.length > 0) {
                    subcats.forEach(subcat => {
                        const subcatItem = document.createElement('div');
                        subcatItem.style.cssText = 'padding: 6px 8px; margin: 2px 0; color: #555; cursor: pointer; border-radius: 6px; transition: all 0.2s; background: #f8f9fa;';
                        subcatItem.innerHTML = `‚îî <strong>${subcat}</strong> <span style="color: #999;">(${categoryFiles[category][subcat].length} file${categoryFiles[category][subcat].length !== 1 ? 's' : ''})</span>`;

                        // Hover effect
                        subcatItem.addEventListener('mouseenter', function() {
                            this.style.background = '#667eea';
                            this.style.color = 'white';
                            const span = this.querySelector('span');
                            if (span) span.style.color = '#e0e7ff';
                        });

                        subcatItem.addEventListener('mouseleave', function() {
                            this.style.background = '#f8f9fa';
                            this.style.color = '#555';
                            const span = this.querySelector('span');
                            if (span) span.style.color = '#999';
                        });

                        // Click handler for subcategory - load specific subcategory only
                        subcatItem.addEventListener('click', (e) => {
                            e.stopPropagation(); // Prevent triggering parent category click
                            loadSubcategoryVocabulary(category, subcat);
                        });

                        subcatList.appendChild(subcatItem);
                    });
                    categoryCard.appendChild(subcatList);
                }

                // Click handler to load category vocabulary (all files in category)
                categoryCard.addEventListener('click', (e) => {
                    // Only trigger if clicked directly on card, not on subcategory
                    if (e.target === categoryCard || e.target.closest('.category-card-header')) {
                        loadCategoryVocabulary(category);
                    }
                });

                browserList.appendChild(categoryCard);
            });
        }

        function loadCategoryVocabulary(categoryName) {
            // Get all files in this category
            const filesInCategory = Object.keys(fileCategories).filter(fileName => {
                return fileCategories[fileName].category === categoryName;
            });

            if (filesInCategory.length === 0) {
                alert(`No files found in category "${categoryName}"`);
                return;
            }

            // Show selection dialog if multiple files
            if (filesInCategory.length > 1) {
                let message = `Select a file from "${categoryName}":\n\n`;
                filesInCategory.forEach((file, idx) => {
                    const subcat = fileCategories[file].subcategory;
                    message += `${idx + 1}. ${file}${subcat ? ' (' + subcat + ')' : ''}\n`;
                });

                const selection = prompt(message + '\nEnter file number:');
                if (selection) {
                    const index = parseInt(selection) - 1;
                    if (index >= 0 && index < filesInCategory.length) {
                        loadFileByName(filesInCategory[index]);
                    }
                }
            } else {
                // Load the single file
                loadFileByName(filesInCategory[0]);
            }
        }

        function loadSubcategoryVocabulary(categoryName, subcategoryName) {
            console.log('üìã Loading subcategory:', categoryName, '‚Üí', subcategoryName);

            // Get all files in this specific subcategory
            const filesInSubcategory = Object.keys(fileCategories).filter(fileName => {
                return fileCategories[fileName].category === categoryName &&
                       fileCategories[fileName].subcategory === subcategoryName;
            });

            if (filesInSubcategory.length === 0) {
                alert(`No files found in subcategory "${categoryName} ‚Üí ${subcategoryName}"`);
                return;
            }

            // Show selection dialog if multiple files
            if (filesInSubcategory.length > 1) {
                let message = `Select a file from "${categoryName} ‚Üí ${subcategoryName}":\n\n`;
                filesInSubcategory.forEach((file, idx) => {
                    message += `${idx + 1}. ${file}\n`;
                });

                const selection = prompt(message + '\nEnter file number:');
                if (selection) {
                    const index = parseInt(selection) - 1;
                    if (index >= 0 && index < filesInSubcategory.length) {
                        loadFileByName(filesInSubcategory[index]);
                    }
                }
            } else {
                // Load the single file
                loadFileByName(filesInSubcategory[0]);
            }
        }

        function loadFileByName(fileName) {
            // Try to load from localStorage
            const savedData = localStorage.getItem(`flashcards_${fileName}`);

            if (!savedData) {
                alert(`Vocabulary data for "${fileName}" not found. Please upload the file again.`);
                return;
            }

            try {
                const cardData = JSON.parse(savedData);

                // Reconstruct flashcards from saved data
                flashcards = cardData.map((card, index) => ({
                    id: index,
                    german: card.german,
                    germanExtended: card.germanExtended || '',
                    english: card.english,
                    englishExtended: card.englishExtended || '',
                    detail: card.detail || '',
                    hasExtended: !!(card.germanExtended || card.englishExtended),
                    learned: card.learned || false,
                    reviewDate: card.reviewDate || null,
                    repetitions: card.repetitions || 0,
                    easeFactor: card.easeFactor || 2.5,
                    interval: card.interval || 1
                }));

                currentFileName = fileName;
                currentIndex = 0;
                filteredCards = [...flashcards];

                // Load file category
                if (fileCategories[currentFileName]) {
                    currentFileCategory = fileCategories[currentFileName];
                }

                // Update UI
                const dueCount = flashcards.filter(isDueForReview).length;
                fileInfo.innerHTML = `<strong>üìÇ ${currentFileName}</strong><br>‚úÖ Loaded ${flashcards.length} cards (${dueCount} due for review) from saved data`;

                updateStats();
                showFlashcard();
                updateCurrentFileDisplay();

                // Show main UI elements
                flashcardContainer.style.display = 'block';
                navigation.style.display = 'flex';
                stats.style.display = 'block';
                document.getElementById('quickActions').style.display = 'grid';
                document.getElementById('settingsToggleBtn').style.display = 'flex';
                document.getElementById('clearFileBtn').style.display = 'inline-block';
                document.getElementById('instructions').style.display = 'none';

                // Scroll to flashcard
                flashcardContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });

            } catch (error) {
                console.error('Error loading saved vocabulary:', error);
                alert('Error loading vocabulary data. Please upload the file again.');
            }
        }

        // TEST FUNCTION - For testing suggestion display
        function testAutoOpen() {
            console.log('üß™ TEST: Manual trigger of suggestion display');
            console.log('üß™ TEST: Using lastDetectedSuggestion:', window.lastDetectedSuggestion);

            // Use real suggestion if available, otherwise use test values
            let testCategory = 'TestCategory';
            let testSubcategory = 'TestSubcategory';

            if (window.lastDetectedSuggestion) {
                testCategory = window.lastDetectedSuggestion.category;
                testSubcategory = window.lastDetectedSuggestion.subcategory;
                console.log('üß™ TEST: Using real detected values');
            } else if (window.pendingCategorySuggestion) {
                testCategory = window.pendingCategorySuggestion.category;
                testSubcategory = window.pendingCategorySuggestion.subcategory;
                console.log('üß™ TEST: Using pending suggestion');
            } else {
                console.log('üß™ TEST: No suggestion found, using test values');
            }

            showCategorySuggestion(testCategory, testSubcategory);
            console.log('‚úÖ TEST: Suggestion display triggered');
        }

        // Load categories and render browser on page load
        loadCategories();
        renderCategoryBrowser();

        const csvFileInput = document.getElementById('csvFile');
        const fileInfo = document.getElementById('fileInfo');
        const flashcardContainer = document.getElementById('flashcardContainer');
        const flashcard = document.getElementById('flashcard');
        const navigation = document.getElementById('navigation');
        const germanWord = document.getElementById('germanWord');
        const englishWord = document.getElementById('englishWord');
        const detailBack = document.getElementById('detailBack');
        const progress = document.getElementById('progress');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const controlButtons = document.getElementById('controlButtons');
        const stats = document.getElementById('stats');
        const learnedCount = document.getElementById('learnedCount');
        const remainingCount = document.getElementById('remainingCount');
        const totalCount = document.getElementById('totalCount');
        const shuffleBtn = document.getElementById('shuffleBtn');
        const learnedBtn = document.getElementById('learnedBtn');
        const resetBtn = document.getElementById('resetBtn');
        const showLearnedBtn = document.getElementById('showLearnedBtn');
        const learnedBadge = document.getElementById('learnedBadge');
        const audioBtn = document.getElementById('audioBtn');
        const reviewInfo = document.getElementById('reviewInfo');
        const englishSection = document.getElementById('englishSection');
        const revealBtn = document.getElementById('revealBtn');
        const alwaysShowMeaningsCheckbox = document.getElementById('alwaysShowMeanings');
        const showMeaningsToggle = document.getElementById('showMeaningsToggle');
        const audioBtnEnglish = document.getElementById('audioBtnEnglish');

        // Auto-play elements
        const autoplayBtn = document.getElementById('autoplayBtn');
        const autoplaySettings = document.getElementById('autoplaySettings');
        const autoplayEnglishCheckbox = document.getElementById('autoplayEnglish');
        const delayBetweenSlider = document.getElementById('delayBetween');
        const delayNextSlider = document.getElementById('delayNext');
        const delayBetweenValue = document.getElementById('delayBetweenValue');
        const delayNextValue = document.getElementById('delayNextValue');

        // Handle file upload
        csvFileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                console.log('üÜï New file upload detected:', file.name);

                // Clear any pending suggestion from previous file
                window.pendingCategorySuggestion = null;
                window.lastDetectedSuggestion = null;
                console.log('   Cleared pending suggestions');

                // Hide format selector and suggestion box from previous upload
                const formatSelector = document.getElementById('formatSelector');
                const suggestionBox = document.getElementById('suggestedCategorySection');
                if (formatSelector) {
                    formatSelector.style.display = 'none';
                    console.log('   Hidden format selector');
                }
                if (suggestionBox) {
                    suggestionBox.style.display = 'none';
                    console.log('   Hidden suggestion box');
                }

                // Reset column mapping
                columnMapping = null;
                console.log('   Reset column mapping');

                fileInfo.textContent = `Loading: ${file.name}`;
                parseCSV(file);
            }
        });

        // Handle clear file button
        document.getElementById('clearFileBtn').addEventListener('click', () => {
            if (confirm('Remove current file and reset? All unsaved progress will be kept in browser storage.')) {
                console.log('üóëÔ∏è Clearing current file and resetting UI');

                // Reset file input
                csvFileInput.value = '';

                // Clear current data
                flashcards = [];
                filteredCards = [];
                currentIndex = 0;
                currentFileName = '';

                // Clear suggestions
                window.pendingCategorySuggestion = null;
                window.lastDetectedSuggestion = null;
                console.log('   Cleared suggestions');

                // Stop any ongoing auto-play
                stopAutoPlay();

                // Hide UI elements
                flashcardContainer.style.display = 'none';
                navigation.style.display = 'none';
                stats.style.display = 'none';
                document.getElementById('quickActions').style.display = 'none';
                document.getElementById('settingsToggleBtn').style.display = 'none';
                document.getElementById('settingsMenu').style.display = 'none';
                document.getElementById('clearFileBtn').style.display = 'none';
                document.getElementById('sessionStats').style.display = 'none';
                document.getElementById('timerDisplay').style.display = 'none';

                // Hide format selector and suggestion box
                const formatSelector = document.getElementById('formatSelector');
                const suggestionBox = document.getElementById('suggestedCategorySection');
                if (formatSelector) {
                    formatSelector.style.display = 'none';
                }
                if (suggestionBox) {
                    suggestionBox.style.display = 'none';
                }
                console.log('   Hidden format selector and suggestion box');

                // Update file info
                fileInfo.textContent = 'File removed. Upload a new CSV file to continue.';

                // Show instructions again
                document.getElementById('instructions').style.display = 'block';

                console.log('‚úÖ File cleared successfully');
            }
        });

        // LocalStorage functions
        function saveProgress() {
            if (currentFileName && flashcards.length > 0) {
                const progressData = flashcards.map(card => ({
                    german: card.german,
                    english: card.english,
                    learned: card.learned,
                    reviewDate: card.reviewDate || null,
                    repetitions: card.repetitions || 0,
                    easeFactor: card.easeFactor || 2.5,
                    interval: card.interval || 1
                }));
                localStorage.setItem(`flashcards_${currentFileName}`, JSON.stringify(progressData));
            }
        }

        function loadProgress(fileName) {
            const saved = localStorage.getItem(`flashcards_${fileName}`);
            if (saved) {
                return JSON.parse(saved);
            }
            return null;
        }

        // Spaced Repetition Algorithm (SM-2)
        function calculateNextReview(card, quality) {
            // quality: 0-5 (0=total blackout, 5=perfect response)
            let easeFactor = card.easeFactor || 2.5;
            let repetitions = card.repetitions || 0;
            let interval = card.interval || 1;

            if (quality >= 3) {
                // Correct response
                if (repetitions === 0) {
                    interval = 1;
                } else if (repetitions === 1) {
                    interval = 6;
                } else {
                    interval = Math.round(interval * easeFactor);
                }
                repetitions++;
            } else {
                // Incorrect response - restart
                repetitions = 0;
                interval = 1;
            }

            // Update ease factor
            easeFactor = easeFactor + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02));
            if (easeFactor < 1.3) easeFactor = 1.3;

            const nextReviewDate = new Date();
            nextReviewDate.setDate(nextReviewDate.getDate() + interval);

            return {
                repetitions,
                easeFactor,
                interval,
                reviewDate: nextReviewDate.toISOString()
            };
        }

        // Check if card is due for review
        function isDueForReview(card) {
            if (!card.reviewDate) return true;
            return new Date() >= new Date(card.reviewDate);
        }

        // Smart language detection helper
        function detectGerman(text) {
            if (!text) return false;

            // German-specific characters
            const germanChars = /[√§√∂√º√ü√Ñ√ñ√ú]/;
            if (germanChars.test(text)) return true;

            // Common German articles and words (case insensitive)
            const germanWords = /\b(der|die|das|den|dem|des|ein|eine|einen|einem|eines|ich|du|er|sie|es|wir|ihr|und|oder|aber|auch|nicht|ist|sind|haben|hat|zu|auf|in|mit|von|f√ºr)\b/i;
            if (germanWords.test(text)) return true;

            return false;
        }

        function detectEnglish(text) {
            if (!text) return false;

            // Common English articles and words
            const englishWords = /\b(the|a|an|and|or|but|in|on|at|to|for|of|with|by|from|is|are|was|were|be|been|have|has|had|do|does|did|will|would|can|could|should|may|might|must|this|that|these|those|i|you|he|she|it|we|they|about|sorry|happy|sad|feel|feeling|love|surprised|amazed|furious|satisfied|possible|pleased|excited|interested|grateful|thankful|afraid|anxious|fearful)\b/i;
            return englishWords.test(text);
        }

        function isLikelyWord(text) {
            if (!text) return false;
            const trimmed = text.trim();
            // A word/short phrase is typically:
            // - 1-3 words OR
            // - Contains slashes (like "happy / sad / angry") but less than 8 words
            const wordCount = trimmed.split(/\s+/).length;
            const hasSlashes = /\//.test(trimmed);
            return wordCount <= 3 || (hasSlashes && wordCount <= 8);
        }

        function isLikelySentence(text) {
            if (!text) return false;
            const trimmed = text.trim();
            // A sentence is typically: longer text with sentence punctuation
            const wordCount = trimmed.split(/\s+/).length;
            const hasSentencePunctuation = /[.!?]/.test(trimmed);
            // Don't count slash-separated lists as sentences
            const hasSlashes = /\//.test(trimmed);
            return (wordCount > 8 || (wordCount > 3 && hasSentencePunctuation)) && !hasSlashes;
        }

        // Advanced per-row format detection
        function detectRowFormat(parts) {
            if (!parts || parts.length < 2) return null;

            // If manual column mapping is set, use it
            if (columnMapping && Object.keys(columnMapping).length > 0) {
                const result = {
                    german: '',
                    germanExtended: '',
                    english: '',
                    englishExtended: '',
                    detail: ''
                };

                Object.keys(columnMapping).forEach(colKey => {
                    const colIndex = parseInt(colKey.replace('col', ''));
                    const colType = columnMapping[colKey];
                    const colValue = parts[colIndex] ? parts[colIndex].trim() : '';

                    if (colType === 'german') result.german = colValue;
                    else if (colType === 'germanExtended') result.germanExtended = colValue;
                    else if (colType === 'english') result.english = colValue;
                    else if (colType === 'englishExtended') result.englishExtended = colValue;
                });

                console.log('Using manual mapping:', result);
                return result;
            }

            // Otherwise use auto-detection

            // Analyze each column
            const columns = parts.map((part, idx) => {
                const trimmed = part.trim();
                return {
                    index: idx,
                    text: trimmed,
                    isGerman: detectGerman(trimmed),
                    isEnglish: detectEnglish(trimmed),
                    isLong: isLikelySentence(trimmed),
                    isShort: isLikelyWord(trimmed),
                    wordCount: trimmed.split(/\s+/).length
                };
            });

            let result = {
                german: '',
                germanExtended: '',
                english: '',
                englishExtended: '',
                detail: ''
            };

            // Strategy: Find the most likely German word and English word first
            const germanCandidates = columns.filter(c => c.isGerman && !c.isEnglish);
            const englishCandidates = columns.filter(c => c.isEnglish && !c.isGerman);
            const ambiguousCandidates = columns.filter(c => !c.isGerman && !c.isEnglish);

            console.log('Detection analysis:', {
                germanCandidates: germanCandidates.map(c => ({index: c.index, text: c.text, wordCount: c.wordCount, isShort: c.isShort, isLong: c.isLong})),
                englishCandidates: englishCandidates.map(c => ({index: c.index, text: c.text, wordCount: c.wordCount, isShort: c.isShort, isLong: c.isLong})),
                ambiguousCandidates: ambiguousCandidates.map(c => ({index: c.index, text: c.text, wordCount: c.wordCount}))
            });

            // IMPROVED: Prioritize shortest German word (1-3 words) as main vocab
            const germanShortWords = germanCandidates.filter(c => c.isShort).sort((a, b) => a.wordCount - b.wordCount);
            let germanWord = germanShortWords[0] || germanCandidates.sort((a, b) => a.wordCount - b.wordCount)[0];

            // IMPROVED: Prioritize shortest English word (1-3 words) as main translation
            const englishShortWords = englishCandidates.filter(c => c.isShort).sort((a, b) => a.wordCount - b.wordCount);
            let englishWord = englishShortWords[0] || englishCandidates.sort((a, b) => a.wordCount - b.wordCount)[0];

            // CRITICAL FIX: If we have ambiguous (undetected) columns AND detected candidates,
            // check if the ambiguous column is SHORTER - if so, use it as the main word
            if (ambiguousCandidates.length > 0) {
                // Sort ambiguous by word count to find shortest
                const sortedAmbiguous = ambiguousCandidates.sort((a, b) => a.wordCount - b.wordCount);
                const shortestAmbiguous = sortedAmbiguous[0];

                // If we have a German candidate but ambiguous is shorter, use ambiguous as German
                if (germanWord && shortestAmbiguous.wordCount < germanWord.wordCount) {
                    console.log(`Overriding German word: "${germanWord.text}" (${germanWord.wordCount} words) with ambiguous: "${shortestAmbiguous.text}" (${shortestAmbiguous.wordCount} words)`);
                    // Move current germanWord to long position
                    const germanLongTemp = germanWord;
                    germanWord = shortestAmbiguous;
                    // Remove this ambiguous from list
                    const ambIdx = ambiguousCandidates.indexOf(shortestAmbiguous);
                    if (ambIdx > -1) ambiguousCandidates.splice(ambIdx, 1);
                }
            }

            // Find long German text (example sentence) - must be different from germanWord
            const germanLong = germanCandidates.find(c => c.isLong && c.index !== germanWord?.index);

            // Find long English text (example sentence) - must be different from englishWord
            const englishLong = englishCandidates.find(c => c.isLong && c.index !== englishWord?.index);

            console.log('Selected words:', {
                germanWord: germanWord?.text,
                germanLong: germanLong?.text,
                englishWord: englishWord?.text,
                englishLong: englishLong?.text
            });

            if (germanWord) result.german = germanWord.text;
            if (germanLong) result.germanExtended = germanLong.text;
            if (englishWord) result.english = englishWord.text;
            if (englishLong) result.englishExtended = englishLong.text;

            // Handle ambiguous columns (could be either language)
            if (!germanWord && !englishWord && parts.length >= 2) {
                // Fallback: assume first two columns are German, English
                result.german = parts[0].trim();
                result.english = parts[1].trim();
                if (parts.length > 2) result.detail = parts.slice(2).join(', ');
            } else if (!englishWord && germanCandidates.length >= 2) {
                // Special case: We have 2+ German columns but NO English
                // This likely means: German word, German example, English (misdetected as German or ambiguous)

                // Sort all candidates by position
                const sortedGerman = germanCandidates.sort((a, b) => a.index - b.index);

                // Strategy:
                // - SHORTEST German candidate = German word
                // - Remaining columns = figure out which is German example vs English

                // Find shortest German candidate
                const shortestGerman = [...germanCandidates].sort((a, b) => a.wordCount - b.wordCount)[0];
                result.german = shortestGerman.text;

                // Get remaining candidates
                const remainingCandidates = columns.filter(c => c.index !== shortestGerman.index);

                // If we have exactly 2 remaining columns:
                if (remainingCandidates.length === 2) {
                    // Assume: [German Extended, English] in order
                    // The one with more German markers = German Extended
                    // The one with fewer German markers = English (even if has some German words)
                    const first = remainingCandidates[0];
                    const second = remainingCandidates[1];

                    // Count German-specific characters
                    const firstGermanScore = (first.text.match(/[√§√∂√º√ü√Ñ√ñ√ú]/g) || []).length;
                    const secondGermanScore = (second.text.match(/[√§√∂√º√ü√Ñ√ñ√ú]/g) || []).length;

                    if (firstGermanScore > secondGermanScore) {
                        result.germanExtended = first.text;
                        result.english = second.text;
                    } else if (secondGermanScore > firstGermanScore) {
                        result.germanExtended = second.text;
                        result.english = first.text;
                    } else {
                        // Equal scores or both zero - use position-based fallback
                        // First remaining = German extended, Second = English
                        result.germanExtended = first.text;
                        result.english = second.text;
                    }
                } else if (remainingCandidates.length === 1) {
                    // Only one remaining - treat as English
                    result.english = remainingCandidates[0].text;
                } else {
                    // More than 2 remaining - take first two by position
                    result.germanExtended = remainingCandidates[0].text;
                    result.english = remainingCandidates[1].text;
                }

                console.log('Multiple German, no English detected - using smart positional fallback');
            } else if (!germanWord && englishWord) {
                // Only English detected, guess German from remaining
                // Prioritize SHORT words over LONG sentences
                const remainingCols = columns.filter(c => c.index !== englishWord.index && c.index !== englishLong?.index);
                const shortRemaining = remainingCols.filter(c => c.isShort).sort((a, b) => a.wordCount - b.wordCount);
                result.german = (shortRemaining[0] || remainingCols[0])?.text || '';

                // The longer remaining text becomes germanExtended
                const longRemaining = remainingCols.find(c => c.isLong && c.text !== result.german);
                if (longRemaining) result.germanExtended = longRemaining.text;
            } else if (germanWord && !englishWord) {
                // Only German detected, guess English from remaining
                // Prioritize SHORT words over LONG sentences
                const remainingCols = columns.filter(c => c.index !== germanWord.index && c.index !== germanLong?.index);
                const shortRemaining = remainingCols.filter(c => c.isShort).sort((a, b) => a.wordCount - b.wordCount);
                result.english = (shortRemaining[0] || remainingCols[0])?.text || '';

                // The longer remaining text becomes englishExtended
                const longRemaining = remainingCols.find(c => c.isLong && c.text !== result.english);
                if (longRemaining) result.englishExtended = longRemaining.text;
            }

            // Collect any remaining columns as detail
            const usedIndices = [
                germanWord?.index,
                germanLong?.index,
                englishWord?.index,
                englishLong?.index
            ].filter(i => i !== undefined);

            const unusedColumns = columns.filter(c => !usedIndices.includes(c.index));
            if (unusedColumns.length > 0) {
                result.detail = unusedColumns.map(c => c.text).join(', ');
            }

            return result;
        }

        // Show format selector (3 options)
        function showFormatSelector(lines, separator) {
            document.getElementById('formatSelector').style.display = 'block';
            document.getElementById('instructions').style.display = 'none';

            // Add event listeners to preset format buttons
            document.querySelectorAll('.format-preset-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const format = btn.getAttribute('data-format');
                    applyPredefinedFormat(format);
                });
            });
        }

        // Option 1: Predefined formats
        function selectPredefinedFormat() {
            // Just highlight - buttons already have click handlers
            console.log('Click a preset format button');
        }

        function applyPredefinedFormat(format) {
            console.log('‚öôÔ∏è Applying predefined format:', format);
            console.log('‚öôÔ∏è Pending suggestion still exists?', window.pendingCategorySuggestion);

            // Set column mapping based on format
            columnMapping = {};

            switch(format) {
                case '3col-standard': // German, German Example, English
                    columnMapping = {
                        col0: 'german',
                        col1: 'germanExtended',
                        col2: 'english'
                    };
                    break;
                case '3col-reverse': // English, English Example, German
                    columnMapping = {
                        col0: 'english',
                        col1: 'englishExtended',
                        col2: 'german'
                    };
                    break;
                case '4col-full': // German, German Ex., English, English Ex.
                    columnMapping = {
                        col0: 'german',
                        col1: 'germanExtended',
                        col2: 'english',
                        col3: 'englishExtended'
                    };
                    break;
                case '2col-simple': // German, English
                    columnMapping = {
                        col0: 'german',
                        col1: 'english'
                    };
                    break;
            }

            // Hide selector and reload with predefined mapping
            document.getElementById('formatSelector').style.display = 'none';
            const file = new File([rawFileData], currentFileName, { type: 'text/csv' });
            parseCSV(file, true);
        }

        // Option 2: Manual mapping - Open modal immediately
        function selectManualMapping() {
            document.getElementById('formatSelector').style.display = 'none';
            const lines = rawFileData.split('\n').filter(line => line.trim() !== '');
            showColumnMapperModal(lines, detectedSeparator);
        }

        // Show column mapper in modal popup
        function showColumnMapperModal(lines, separator) {
            const table = document.getElementById('dataPreviewTable');

            // Get first 10 data rows (skip header if present)
            let startIndex = 0;
            const firstLine = lines[0].toLowerCase();
            if (firstLine.includes('german') || firstLine.includes('english') ||
                firstLine.includes('deutsch') || firstLine.includes('word') || firstLine.includes('voc')) {
                startIndex = 1;
            }

            const previewRows = lines.slice(startIndex, Math.min(startIndex + 10, lines.length));
            const sampleData = previewRows.map(line => line.split(separator).map(col => col.trim()));
            const numColumns = sampleData[0].length;

            // Initialize column types (all unassigned initially)
            const columnTypes = new Array(numColumns).fill('unassigned');

            // Build table HTML
            let tableHTML = '<thead><tr>';

            // Create column headers with dropdown selectors
            for (let i = 0; i < numColumns; i++) {
                tableHTML += `
                    <th id="col-header-${i}" data-col-index="${i}" onclick="toggleColumnTypeSelector(${i})" style="position: relative; cursor: pointer;">
                        <div style="font-size: 1.2em; margin-bottom: 5px;">Column ${i + 1}</div>
                        <div class="column-type-selector" id="type-selector-${i}">
                            <div class="type-option" onclick="event.stopPropagation(); setColumnType(${i}, 'german')" style="color: #10b981;">
                                <span style="font-size: 1.5em;">üá©üá™</span>
                                <span>German Word<br><small style="font-weight: normal; opacity: 0.8;">Main vocab (visible)</small></span>
                            </div>
                            <div class="type-option" onclick="event.stopPropagation(); setColumnType(${i}, 'germanExtended')" style="color: #f59e0b;">
                                <span style="font-size: 1.5em;">üìù</span>
                                <span>German Example<br><small style="font-weight: normal; opacity: 0.8;">Hidden until revealed</small></span>
                            </div>
                            <div class="type-option" onclick="event.stopPropagation(); setColumnType(${i}, 'english')" style="color: #3b82f6;">
                                <span style="font-size: 1.5em;">üá¨üáß</span>
                                <span>English Word<br><small style="font-weight: normal; opacity: 0.8;">Main translation (visible)</small></span>
                            </div>
                            <div class="type-option" onclick="event.stopPropagation(); setColumnType(${i}, 'englishExtended')" style="color: #ec4899;">
                                <span style="font-size: 1.5em;">üìñ</span>
                                <span>English Example<br><small style="font-weight: normal; opacity: 0.8;">Hidden until revealed</small></span>
                            </div>
                            <div class="type-option" onclick="event.stopPropagation(); setColumnType(${i}, 'ignore')" style="color: #94a3b8;">
                                <span style="font-size: 1.5em;">üö´</span>
                                <span>Ignore Column<br><small style="font-weight: normal; opacity: 0.8;">Skip this data</small></span>
                            </div>
                        </div>
                    </th>
                `;
            }
            tableHTML += '</tr></thead><tbody>';

            // Add data rows
            sampleData.forEach((row, rowIndex) => {
                tableHTML += '<tr>';
                row.forEach((cell, colIndex) => {
                    const displayText = cell.length > 40 ? cell.substring(0, 40) + '...' : cell;
                    tableHTML += `<td title="${cell}">${displayText}</td>`;
                });
                tableHTML += '</tr>';
            });

            tableHTML += '</tbody>';
            table.innerHTML = tableHTML;

            // Store column types globally for later use
            window.currentColumnTypes = columnTypes;

            // Show the modal
            document.getElementById('columnMapperModal').style.display = 'flex';
        }

        // Close column mapper modal
        function closeColumnMapperModal() {
            document.getElementById('columnMapperModal').style.display = 'none';
            // Only show format selector again if user cancelled (not applied)
            if (!flashcards || flashcards.length === 0) {
                document.getElementById('formatSelector').style.display = 'block';
            }
        }

        // Option 3: Auto-detection
        function selectAutoDetection() {
            console.log('‚öôÔ∏è Auto-detection selected');
            console.log('‚öôÔ∏è Pending suggestion still exists?', window.pendingCategorySuggestion);
            console.log('‚öôÔ∏è rawFileData exists?', !!rawFileData);
            console.log('‚öôÔ∏è currentFileName:', currentFileName);

            columnMapping = null; // Reset to auto-detect
            document.getElementById('formatSelector').style.display = 'none';

            try {
                const file = new File([rawFileData], currentFileName, { type: 'text/csv' });
                console.log('‚öôÔ∏è File object created:', file);
                parseCSV(file, true);
            } catch (error) {
                console.error('‚ùå ERROR in selectAutoDetection:', error);
                alert('ERROR: ' + error.message);
            }
        }

        // Show column mapping interface with data preview table
        function showColumnMapper(lines, separator) {
            const columnMapper = document.getElementById('columnMapper');
            const table = document.getElementById('dataPreviewTable');

            // Get first 10 data rows (skip header if present)
            let startIndex = 0;
            const firstLine = lines[0].toLowerCase();
            if (firstLine.includes('german') || firstLine.includes('english') ||
                firstLine.includes('deutsch') || firstLine.includes('word') || firstLine.includes('voc')) {
                startIndex = 1;
            }

            const previewRows = lines.slice(startIndex, Math.min(startIndex + 10, lines.length));
            const sampleData = previewRows.map(line => line.split(separator).map(col => col.trim()));
            const numColumns = sampleData[0].length;

            // Initialize column types (all unassigned initially)
            const columnTypes = new Array(numColumns).fill('unassigned');

            // Build table HTML
            let tableHTML = '<thead><tr>';

            // Create column headers with dropdown selectors
            for (let i = 0; i < numColumns; i++) {
                tableHTML += `
                    <th id="col-header-${i}" data-col-index="${i}" onclick="toggleColumnTypeSelector(${i})" style="position: relative; cursor: pointer;">
                        <div style="font-size: 1.2em; margin-bottom: 5px;">Column ${i + 1}</div>
                        <div class="column-type-selector" id="type-selector-${i}">
                            <div class="type-option" onclick="event.stopPropagation(); setColumnType(${i}, 'german')" style="color: #10b981;">
                                <span style="font-size: 1.5em;">üá©üá™</span>
                                <span>German Word<br><small style="font-weight: normal; opacity: 0.8;">Main vocab (visible)</small></span>
                            </div>
                            <div class="type-option" onclick="event.stopPropagation(); setColumnType(${i}, 'germanExtended')" style="color: #f59e0b;">
                                <span style="font-size: 1.5em;">üìù</span>
                                <span>German Example<br><small style="font-weight: normal; opacity: 0.8;">Hidden until revealed</small></span>
                            </div>
                            <div class="type-option" onclick="event.stopPropagation(); setColumnType(${i}, 'english')" style="color: #3b82f6;">
                                <span style="font-size: 1.5em;">üá¨üáß</span>
                                <span>English Word<br><small style="font-weight: normal; opacity: 0.8;">Main translation (visible)</small></span>
                            </div>
                            <div class="type-option" onclick="event.stopPropagation(); setColumnType(${i}, 'englishExtended')" style="color: #ec4899;">
                                <span style="font-size: 1.5em;">üìñ</span>
                                <span>English Example<br><small style="font-weight: normal; opacity: 0.8;">Hidden until revealed</small></span>
                            </div>
                            <div class="type-option" onclick="event.stopPropagation(); setColumnType(${i}, 'ignore')" style="color: #94a3b8;">
                                <span style="font-size: 1.5em;">üö´</span>
                                <span>Ignore Column<br><small style="font-weight: normal; opacity: 0.8;">Skip this data</small></span>
                            </div>
                        </div>
                    </th>
                `;
            }
            tableHTML += '</tr></thead><tbody>';

            // Add data rows
            sampleData.forEach((row, rowIndex) => {
                tableHTML += '<tr>';
                row.forEach((cell, colIndex) => {
                    const displayText = cell.length > 40 ? cell.substring(0, 40) + '...' : cell;
                    tableHTML += `<td title="${cell}">${displayText}</td>`;
                });
                tableHTML += '</tr>';
            });

            tableHTML += '</tbody>';
            table.innerHTML = tableHTML;

            // Store column types globally for later use
            window.currentColumnTypes = columnTypes;

            // Show the mapper
            columnMapper.style.display = 'block';
            document.getElementById('instructions').style.display = 'none';
        }

        // Toggle column type selector - Show dropdown
        function toggleColumnTypeSelector(colIndex) {
            const selector = document.getElementById(`type-selector-${colIndex}`);
            if (!selector) return;

            // Close all other selectors
            document.querySelectorAll('.column-type-selector.active').forEach(s => {
                if (s !== selector) s.classList.remove('active');
            });

            // Toggle current selector - CSS handles positioning automatically
            selector.classList.add('active');
        }

        // Set column type
        function setColumnType(colIndex, type) {
            window.currentColumnTypes[colIndex] = type;

            const header = document.getElementById(`col-header-${colIndex}`);

            // Remove all type classes
            header.classList.remove('type-german', 'type-germanExtended', 'type-english', 'type-englishExtended', 'type-ignore');

            // Add new type class
            if (type !== 'unassigned') {
                header.classList.add(`type-${type}`);
            }

            // Update header text and visual appearance
            const typeInfo = {
                'german': { icon: 'üá©üá™', name: 'German Word', desc: 'Main vocab (visible)' },
                'germanExtended': { icon: 'üìù', name: 'German Example', desc: 'Extended (hidden)' },
                'english': { icon: 'üá¨üáß', name: 'English Word', desc: 'Main translation (visible)' },
                'englishExtended': { icon: 'üìñ', name: 'English Example', desc: 'Extended (hidden)' },
                'ignore': { icon: 'üö´', name: 'Ignored', desc: 'Will be skipped' }
            };

            const info = typeInfo[type];

            // Preserve the dropdown selector HTML
            const selectorHTML = header.querySelector('.column-type-selector').outerHTML;

            // Update header content while keeping the dropdown
            header.innerHTML = `
                <div style="font-size: 2em; margin-bottom: 8px;">${info.icon}</div>
                <div style="font-size: 1em; font-weight: 600;">${info.name}</div>
                <div style="font-size: 0.75em; font-weight: normal; margin-top: 5px; opacity: 0.9;">${info.desc}</div>
                ${selectorHTML}
            `;

            // Re-attach the onclick event
            header.onclick = () => toggleColumnTypeSelector(colIndex);

            // Close all dropdowns
            document.querySelectorAll('.column-type-selector').forEach(selector => {
                selector.classList.remove('active');
            });

            console.log('Column', colIndex, 'set to', type);
        }

        // Close dropdowns when clicking outside, and close mapper modal when clicking overlay
        document.addEventListener('click', (e) => {
            const columnMapperModal = document.getElementById('columnMapperModal');

            // Close mapper modal if clicking on overlay
            if (e.target === columnMapperModal) {
                closeColumnMapperModal();
            }

            // Close dropdowns if clicking outside column headers and dropdowns
            if (!e.target.closest('th') && !e.target.closest('.column-type-selector')) {
                document.querySelectorAll('.column-type-selector').forEach(selector => {
                    selector.classList.remove('active');
                });
            }
        });

        // Process file with manual column mapping
        function processWithManualMapping() {
            // Build column mapping from user selections in the table
            columnMapping = {};
            window.currentColumnTypes.forEach((type, index) => {
                if (type !== 'ignore' && type !== 'unassigned') {
                    columnMapping[`col${index}`] = type;
                }
            });

            console.log('Manual column mapping:', columnMapping);

            // Validate that at least German and English are set
            const hasGerman = Object.values(columnMapping).includes('german');
            const hasEnglish = Object.values(columnMapping).includes('english');

            if (!hasGerman || !hasEnglish) {
                alert('Please assign at least one German Word column and one English Word column!');
                return;
            }

            // Close modal and continue with parsing
            closeColumnMapperModal();

            // Re-parse with manual mapping enabled
            const file = new File([rawFileData], currentFileName, { type: 'text/csv' });
            parseCSV(file, true);
        }

        // Use auto-detection (skip manual mapping)
        function useAutoDetection() {
            columnMapping = null; // Reset to auto-detect
            document.getElementById('columnMapper').style.display = 'none';

            // Re-parse with auto-detection
            const file = new File([rawFileData], currentFileName, { type: 'text/csv' });
            parseCSV(file, true);
        }

        // Detect CSV separator (comma, semicolon, tab, or pipe)
        function detectSeparator(text) {
            const lines = text.split('\n').filter(line => line.trim() !== '');
            if (lines.length === 0) return ',';

            const firstLine = lines[0];
            const separators = [',', ';', '\t', '|'];
            let bestSeparator = ',';
            let maxColumns = 0;

            for (const sep of separators) {
                const columns = firstLine.split(sep).length;
                if (columns > maxColumns && columns >= 2) {
                    maxColumns = columns;
                    bestSeparator = sep;
                }
            }

            return bestSeparator;
        }

        // Parse CSV file with smart format detection
        function parseCSV(file, useManualMapping = false) {
            console.log('üöÄ parseCSV CALLED! File:', file.name, 'useManualMapping:', useManualMapping);

            const reader = new FileReader();
            reader.onload = (e) => {
                console.log('üìñ File read complete, parsing...');
                const text = e.target.result;
                const lines = text.split('\n').filter(line => line.trim() !== '');

                currentFileName = file.name;
                rawFileData = text;
                console.log('üìÅ Current file:', currentFileName, '| Lines:', lines.length);

                // Detect separator automatically
                detectedSeparator = detectSeparator(text);
                console.log('Detected separator:', detectedSeparator === '\t' ? 'TAB' : detectedSeparator);

                // Store suggestion data for later (after parsing completes)
                // Only generate suggestion on FIRST parse (not on re-parse with format selection)
                if (!window.pendingCategorySuggestion) {
                    window.pendingCategorySuggestion = suggestCategoryFromFile(currentFileName, text);
                    console.log('üîç Category suggestion prepared (first time):', window.pendingCategorySuggestion);
                } else {
                    console.log('üîç Category suggestion already exists (re-parse):', window.pendingCategorySuggestion);
                }

                // Show format selector on first load (unless explicitly using a method)
                if (!useManualMapping) {
                    console.log('üìã Showing format selector (suggestion will trigger after format is selected)');
                    showFormatSelector(lines, detectedSeparator);
                    return;
                }

                // Continue with actual parsing
                const savedProgress = loadProgress(currentFileName);

                // Check if first line is a header
                let startIndex = 0;
                const firstLine = lines[0].toLowerCase();
                if (firstLine.includes('german') || firstLine.includes('english') ||
                    firstLine.includes('deutsch') || firstLine.includes('word') ||
                    firstLine.includes('voc')) {
                    startIndex = 1; // Skip header row
                }

                flashcards = lines.slice(startIndex).map((line, index) => {
                    const parts = line.split(detectedSeparator).map(part => part.trim());

                    if (parts.length < 2) return null; // Need at least 2 columns

                    // Use new per-row format detection
                    const detected = detectRowFormat(parts);

                    if (!detected || !detected.german || !detected.english) {
                        // Fallback if detection fails
                        console.warn('Detection failed for row:', index, parts);
                        return null;
                    }

                    let german = detected.german;
                    let germanExtended = detected.germanExtended;
                    let english = detected.english;
                    let englishExtended = detected.englishExtended;
                    let detail = detected.detail;

                    // Check if we have saved progress for this card
                    const savedCard = savedProgress?.find(s => s.german === german && s.english === english);

                    const cardData = {
                        id: index,
                        german: german,
                        germanExtended: germanExtended,
                        english: english,
                        englishExtended: englishExtended,
                        detail: detail,
                        hasExtended: !!(germanExtended || englishExtended),
                        learned: savedCard?.learned || false,
                        reviewDate: savedCard?.reviewDate || null,
                        repetitions: savedCard?.repetitions || 0,
                        easeFactor: savedCard?.easeFactor || 2.5,
                        interval: savedCard?.interval || 1
                    };

                    // Debug logging for first 3 cards
                    if (index < 3) {
                        console.log(`Card ${index} parsed:`, cardData);
                        console.log(`Card ${index} raw columns:`, {
                            col0: parts[0],
                            col1: parts[1],
                            col2: parts[2],
                            col3: parts[3]
                        });
                    }

                    return cardData;
                }).filter(card => card && card.german && card.english);

                if (flashcards.length > 0) {
                    const dueCount = flashcards.filter(isDueForReview).length;
                    const sepName = detectedSeparator === '\t' ? 'TAB' : detectedSeparator === ',' ? 'COMMA' : detectedSeparator === ';' ? 'SEMICOLON' : 'PIPE';
                    const extCount = flashcards.filter(card => card.hasExtended).length;
                    fileInfo.innerHTML = `<strong>üìÇ ${currentFileName}</strong><br>‚úÖ Loaded ${flashcards.length} cards (${dueCount} due for review) | Separator: ${sepName} | Extended: ${extCount}`;
                    currentIndex = 0;
                    filteredCards = [...flashcards];

                    // Check if file already has a category assigned
                    const fileAlreadyCategorized = fileCategories[currentFileName] != null;
                    console.log('üìÇ File already categorized?', fileAlreadyCategorized);

                    if (fileCategories[currentFileName]) {
                        currentFileCategory = fileCategories[currentFileName];
                        console.log('   Existing category:', currentFileCategory);
                    } else {
                        // DON'T create default category yet - wait for user to accept/reject suggestion
                        currentFileCategory = { category: 'Default', subcategory: '' };
                        console.log('   Using temporary default category (not saved yet)');
                    }

                    updateStats(); // This calls saveProgress() which saves flashcards to localStorage
                    showFlashcard();
                    updateCurrentFileDisplay();

                    console.log('üíæ Flashcards saved to localStorage:', currentFileName, flashcards.length, 'cards');

                    // NOW show category suggestion AFTER flashcards are saved
                    console.log('üîç Checking for pending category suggestion...');
                    console.log('   File already categorized?', fileAlreadyCategorized);
                    console.log('   pendingCategorySuggestion:', window.pendingCategorySuggestion);

                    // Show main UI elements FIRST
                    flashcardContainer.style.display = 'block';
                    navigation.style.display = 'flex';
                    stats.style.display = 'block';

                    // Show new UI elements
                    document.getElementById('quickActions').style.display = 'grid';
                    document.getElementById('settingsToggleBtn').style.display = 'flex';
                    document.getElementById('clearFileBtn').style.display = 'inline-block';

                    // Hide instructions after successful load
                    document.getElementById('instructions').style.display = 'none';

                    // Show category suggestion AFTER all UI is visible (SIMPLIFIED - no auto-open needed!)
                    console.log('üîç Checking pending suggestion. Value:', window.pendingCategorySuggestion);
                    console.log('üîç File already categorized?', fileAlreadyCategorized);
                    console.log('üîç Current fileName:', currentFileName);

                    // ALWAYS show suggestion if one exists (for testing - we can refine later)
                    if (window.pendingCategorySuggestion) {
                        const suggestion = window.pendingCategorySuggestion;
                        console.log('üìã Suggestion found! Showing it now. Category:', suggestion.category, 'Subcategory:', suggestion.subcategory);

                        // Store for later reference
                        window.lastDetectedSuggestion = {
                            category: suggestion.category,
                            subcategory: suggestion.subcategory
                        };

                        window.pendingCategorySuggestion = null; // Clear pending

                        // Simply show the suggestion box (it's now outside category management!)
                        setTimeout(() => {
                            console.log('‚è∞ About to call showCategorySuggestion...');
                            showCategorySuggestion(suggestion.category, suggestion.subcategory);
                            console.log('‚úÖ showCategorySuggestion called');
                        }, 500);
                    } else {
                        console.log('‚ö†Ô∏è NO pending suggestion found!');
                        console.log('   This means either:');
                        console.log('   1. No suggestion was detected from filename');
                        console.log('   2. Suggestion was cleared somewhere');
                        console.log('   3. This is a re-parse without suggestion');

                        // If no suggestion and file is new, save default category now
                        if (!fileAlreadyCategorized) {
                            fileCategories[currentFileName] = currentFileCategory;
                            saveCategories();
                        }
                    }
                } else {
                    fileInfo.textContent = '‚ùå No valid flashcards found in file';
                    document.getElementById('clearFileBtn').style.display = 'none';
                }
            };
            reader.readAsText(file);
        }

        // Update statistics
        function updateStats() {
            const learned = flashcards.filter(card => card.learned).length;
            const total = flashcards.length;
            const remaining = total - learned;

            learnedCount.textContent = learned;
            remainingCount.textContent = remaining;
            totalCount.textContent = total;

            saveProgress(); // Save whenever stats update
        }

        // Pronounce German word
        function pronounceGerman(text) {
            if (!synth) return;

            synth.cancel(); // Stop any ongoing speech

            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = 'de-DE';
            if (germanVoice) {
                utterance.voice = germanVoice;
            }
            utterance.rate = speechRate; // User-configurable rate
            utterance.pitch = speechPitch; // User-configurable pitch
            synth.speak(utterance);
        }

        // Pronounce English word
        function pronounceEnglish(text) {
            if (!synth) return;

            synth.cancel(); // Stop any ongoing speech

            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = 'en-US';
            if (englishVoice) {
                utterance.voice = englishVoice;
            }
            utterance.rate = speechRate; // User-configurable rate
            utterance.pitch = speechPitch; // User-configurable pitch
            synth.speak(utterance);
        }

        // Get active card list
        function getActiveCards() {
            return showOnlyUnlearned
                ? flashcards.filter(card => !card.learned)
                : flashcards;
        }

        // Show current flashcard
        function showFlashcard() {
            filteredCards = getActiveCards();

            if (filteredCards.length === 0) {
                germanWord.textContent = 'No cards available';
                englishWord.textContent = 'Load a CSV file or adjust filter';
                detailBack.style.display = 'none';
                learnedBadge.style.display = 'none';
                return;
            }

            // Adjust index if out of bounds
            if (currentIndex >= filteredCards.length) {
                currentIndex = filteredCards.length - 1;
            }
            if (currentIndex < 0) {
                currentIndex = 0;
            }

            const card = filteredCards[currentIndex];

            // Debug logging
            console.log('Displaying card:', {
                german: card.german,
                germanExtended: card.germanExtended,
                english: card.english,
                englishExtended: card.englishExtended
            });

            germanWord.textContent = card.german;
            englishWord.textContent = card.english;

            // Show detail and extended content indicators (only English-related content)
            let detailText = '';
            if (card.englishExtended) {
                detailText += `üìù ${card.englishExtended}\n`;
            }
            if (card.detail) {
                detailText += card.detail;
            }

            if (detailText) {
                detailBack.textContent = detailText;
                detailBack.style.display = 'block';
                detailBack.style.whiteSpace = 'pre-line'; // Preserve line breaks
            } else {
                detailBack.style.display = 'none';
            }

            // Show review date info
            if (card.reviewDate && card.repetitions > 0) {
                const reviewDate = new Date(card.reviewDate);
                const daysUntil = Math.ceil((reviewDate - new Date()) / (1000 * 60 * 60 * 24));
                if (daysUntil > 0) {
                    reviewInfo.textContent = `Next review in ${daysUntil} day${daysUntil > 1 ? 's' : ''}`;
                } else if (daysUntil === 0) {
                    reviewInfo.textContent = 'Review due today';
                } else {
                    reviewInfo.textContent = 'Review overdue';
                }
                reviewInfo.style.display = 'block';
            } else {
                reviewInfo.style.display = 'none';
            }

            // Show/hide learned badge
            if (card.learned) {
                learnedBadge.style.display = 'block';
                learnedBtn.textContent = '‚úó Unmark Learned';
            } else {
                learnedBadge.style.display = 'none';
                learnedBtn.textContent = '‚úì Mark as Learned';
            }

            progress.textContent = `${currentIndex + 1} / ${filteredCards.length}`;

            // Handle English section visibility
            if (alwaysShowMeanings) {
                englishSection.classList.add('revealed');
                revealBtn.style.display = 'none';
            } else {
                englishSection.classList.remove('revealed');
                revealBtn.style.display = 'block';
                revealBtn.textContent = 'üëÅ Show English Meaning';
            }

            // Update button states
            prevBtn.disabled = currentIndex === 0;
            nextBtn.disabled = currentIndex === filteredCards.length - 1;
        }

        // Reveal English meaning
        function revealEnglish() {
            englishSection.classList.add('revealed');
            revealBtn.textContent = '‚úì Meaning Shown';
            revealBtn.style.opacity = '0.7';
        }

        // Auto-play functions
        function startAutoPlay() {
            if (filteredCards.length === 0) return;

            isAutoPlaying = true;
            autoplayBtn.textContent = '‚è∏ Stop';
            autoplayBtn.classList.add('playing');

            // Auto-open settings menu and expand auto-play accordion
            document.getElementById('settingsMenu').style.display = 'block';
            document.getElementById('settingsToggleBtn').classList.add('active');

            // Open Auto-Play and Advanced accordions
            const accordions = document.querySelectorAll('.accordion-header');
            accordions.forEach(header => {
                const text = header.textContent;
                if (text.includes('Auto-Play') || text.includes('Advanced Features')) {
                    header.classList.add('active');
                    header.nextElementSibling.classList.add('active');
                }
            });

            // Start session stats
            startSessionStats();

            // Start timers if enabled
            if (studyTimerEnabled) {
                startStudyTimer();
            }
            if (sleepTimerEnabled) {
                startSleepTimer();
            }

            // Start recording if enabled
            const recordCheckbox = document.getElementById('recordSession');
            if (recordCheckbox && recordCheckbox.checked) {
                startRecording();
            }

            // Start from current card
            currentRepeat = 0;
            playCurrentCard();
        }

        function stopAutoPlay(reason = 'manual', autoComplete = false) {
            isAutoPlaying = false;
            autoplayBtn.textContent = '‚ñ∂ Auto-Play';
            autoplayBtn.classList.remove('playing');

            // Clear any pending timeouts
            if (autoplayTimeout) {
                clearTimeout(autoplayTimeout);
                autoplayTimeout = null;
            }

            // Stop any ongoing speech
            if (synth) {
                synth.cancel();
            }

            // Check if recording was enabled (either actively recording or has recorded data)
            const recordCheckbox = document.getElementById('recordSession');
            const wasRecordingEnabled = recordCheckbox && recordCheckbox.checked;
            const hasRecordingData = isRecording || (mediaRecorder && mediaRecorder.state !== 'inactive') || recordedChunks.length > 0;

            // Handle recording based on stop reason
            if (wasRecordingEnabled && hasRecordingData) {
                if (reason === 'manual' && !autoComplete) {
                    // Manual stop - ask user if they want to save recording
                    const saveRecording = confirm('Do you want to save the recorded audio?\n\nClick OK to save, Cancel to discard.');
                    if (saveRecording) {
                        stopRecording();
                        alert('‚úì Recording saved! You can download or play it from the Auto-Play Settings.');
                    } else {
                        // Discard recording
                        if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                            mediaRecorder.stop();
                            mediaRecorder.stream.getTracks().forEach(track => track.stop());
                        }
                        if (recordingTimerInterval) {
                            clearInterval(recordingTimerInterval);
                            recordingTimerInterval = null;
                        }
                        document.getElementById('recordingControls').style.display = 'none';
                        isRecording = false;
                        recordedChunks = [];
                        alert('Recording discarded.');
                    }
                } else {
                    // Automatic end or timer end - always save recording
                    stopRecording();
                    if (reason === 'complete') {
                        alert('‚úÖ Auto-play completed! Recording has been saved automatically.\n\nYou can download or play it from the Auto-Play Settings.');
                    }
                }
            }

            // Stop timers
            stopAllTimers();

            // Show appropriate message (only if recording wasn't already handled)
            const wasRecording = recordedAudioBlob !== null;
            if (reason === 'timer') {
                if (wasRecording) {
                    alert('‚è∞ Time\'s up! Auto-play stopped.\nRecording has been saved automatically.');
                } else {
                    alert('‚è∞ Time\'s up! Auto-play stopped.');
                }
            } else if (reason === 'sleep') {
                if (wasRecording) {
                    alert('üìö Sleep timer complete. Good night!\nRecording has been saved automatically.');
                } else {
                    alert('üìö Sleep timer complete. Good night!');
                }
            } else if (reason === 'complete' && !wasRecording) {
                alert('‚úÖ Auto-play completed! Reached the end of cards.');
            }
        }

        function playCurrentCard() {
            if (!isAutoPlaying || filteredCards.length === 0) return;

            const card = filteredCards[currentIndex];

            // Always reveal English in auto-play mode
            if (!alwaysShowMeanings) {
                revealEnglish();
            }

            // Increment cards reviewed (only once per card, not per repeat)
            if (currentRepeat === 0) {
                cardsReviewedCount++;
                updateSessionStats();
            }

            // Determine what to pronounce
            const germanText = readExtendedContent && card.germanExtended ? card.germanExtended : card.german;
            const englishText = readExtendedContent && card.englishExtended ? card.englishExtended : card.english;

            // Step 1: Pronounce German (word or extended)
            pronounceGerman(germanText);

            // Step 2: Wait, then pronounce English if enabled
            if (autoplayEnglishEnabled) {
                autoplayTimeout = setTimeout(() => {
                    if (!isAutoPlaying) return;
                    pronounceEnglish(englishText);

                    // Step 3: Wait, then move to next card or repeat
                    autoplayTimeout = setTimeout(() => {
                        if (!isAutoPlaying) return;
                        handleCardCompletion();
                    }, delayBeforeNext);
                }, delayBetweenLangs);
            } else {
                // If English not enabled, just wait and move to next or repeat
                autoplayTimeout = setTimeout(() => {
                    if (!isAutoPlaying) return;
                    handleCardCompletion();
                }, delayBeforeNext);
            }
        }

        function handleCardCompletion() {
            if (!isAutoPlaying) return;

            // Check if repeat mode is enabled
            if (repeatModeEnabled && currentRepeat < repeatCount - 1) {
                currentRepeat++;
                playCurrentCard(); // Repeat the same card
            } else {
                currentRepeat = 0; // Reset repeat counter
                moveToNextCardInAutoPlay();
            }
        }

        function moveToNextCardInAutoPlay() {
            if (!isAutoPlaying) return;

            // Move to next card
            if (currentIndex < filteredCards.length - 1) {
                currentIndex++;
                showFlashcard();
                playCurrentCard();
            } else {
                // Reached end
                if (loopModeEnabled) {
                    // Loop back to beginning
                    currentIndex = 0;
                    showFlashcard();
                    playCurrentCard();
                } else {
                    // Stop auto-play with 'complete' reason to auto-save recording
                    stopAutoPlay('complete', true);
                }
            }
        }

        // Timer functions
        function startStudyTimer() {
            const duration = parseInt(document.getElementById('studyDuration').value);
            timerEndTime = Date.now() + (duration * 60 * 1000);
            document.getElementById('timerDisplay').style.display = 'block';
            updateTimerDisplay();
            timerInterval = setInterval(() => {
                updateTimerDisplay();
                if (Date.now() >= timerEndTime) {
                    stopAutoPlay('timer', true); // Auto-save recording
                }
            }, 1000);
        }

        function startSleepTimer() {
            const duration = parseInt(document.getElementById('sleepDuration').value);
            timerEndTime = Date.now() + (duration * 60 * 1000);
            document.getElementById('timerDisplay').style.display = 'block';
            updateTimerDisplay();
            timerInterval = setInterval(() => {
                updateTimerDisplay();
                if (Date.now() >= timerEndTime) {
                    stopAutoPlay('sleep', true); // Auto-save recording
                }
            }, 1000);
        }

        function updateTimerDisplay() {
            if (!timerEndTime) return;
            const remaining = Math.max(0, timerEndTime - Date.now());
            const minutes = Math.floor(remaining / 60000);
            const seconds = Math.floor((remaining % 60000) / 1000);
            document.getElementById('timerText').textContent =
                `‚è±Ô∏è Time Remaining: ${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        function stopAllTimers() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            if (statsInterval) {
                clearInterval(statsInterval);
                statsInterval = null;
            }
            timerEndTime = null;
            document.getElementById('timerDisplay').style.display = 'none';
        }

        // Session stats functions
        function startSessionStats() {
            sessionStartTime = Date.now();
            cardsReviewedCount = 0;
            document.getElementById('sessionStats').style.display = 'block';
            document.getElementById('sessionStart').textContent = new Date().toLocaleTimeString();
            updateSessionStats();
            statsInterval = setInterval(updateSessionStats, 1000);
        }

        function updateSessionStats() {
            if (!sessionStartTime) return;

            const elapsed = Date.now() - sessionStartTime;
            const minutes = Math.floor(elapsed / 60000);
            const seconds = Math.floor((elapsed % 60000) / 1000);

            document.getElementById('cardsReviewed').textContent = cardsReviewedCount;
            document.getElementById('timeStudying').textContent =
                `${minutes}:${seconds.toString().padStart(2, '0')}`;

            const cardsPerMin = minutes > 0 ? (cardsReviewedCount / minutes).toFixed(1) : '0.0';
            document.getElementById('cardsPerMinute').textContent = cardsPerMin;
        }

        // Recording functions
        async function startRecording() {
            try {
                // Request permission to capture tab audio
                const stream = await navigator.mediaDevices.getDisplayMedia({
                    video: true, // Required for tab capture
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false
                    }
                });

                // Stop video track as we only need audio
                const videoTrack = stream.getVideoTracks()[0];
                if (videoTrack) videoTrack.stop();

                recordedChunks = [];
                mediaRecorder = new MediaRecorder(stream);

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = () => {
                    recordedAudioBlob = new Blob(recordedChunks, { type: 'audio/webm' });
                    const audioUrl = URL.createObjectURL(recordedAudioBlob);
                    document.getElementById('recordedAudio').src = audioUrl;
                    document.getElementById('recordedAudioSection').style.display = 'block';
                    isRecording = false;
                };

                mediaRecorder.start();
                isRecording = true;
                recordingStartTime = Date.now();

                // Show recording controls
                document.getElementById('recordingControls').style.display = 'block';

                // Start recording timer
                recordingTimerInterval = setInterval(updateRecordingTimer, 1000);
            } catch (err) {
                console.error('Error starting recording:', err);
                alert('Unable to start recording. Please make sure you grant permission to capture tab audio.');
                isRecording = false;
            }
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();

                // Stop all tracks
                mediaRecorder.stream.getTracks().forEach(track => track.stop());
            }

            if (recordingTimerInterval) {
                clearInterval(recordingTimerInterval);
                recordingTimerInterval = null;
            }

            document.getElementById('recordingControls').style.display = 'none';
        }

        function updateRecordingTimer() {
            if (!recordingStartTime) return;

            const elapsed = Date.now() - recordingStartTime;
            const minutes = Math.floor(elapsed / 60000);
            const seconds = Math.floor((elapsed % 60000) / 1000);

            document.getElementById('recordingTime').textContent =
                `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        function downloadRecording() {
            if (!recordedAudioBlob) return;

            const url = URL.createObjectURL(recordedAudioBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `flashcard-session-${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.webm`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function playRecording() {
            const audio = document.getElementById('recordedAudio');
            audio.style.display = 'block';
            audio.play();
        }

        // Focus Mode functions
        function enterFocusMode() {
            document.getElementById('focusMode').style.display = 'flex';
            document.body.style.overflow = 'hidden';
        }

        function exitFocusMode() {
            document.getElementById('focusMode').style.display = 'none';
            document.body.style.overflow = 'auto';
        }

        // Audio pronunciation - German
        audioBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            if (filteredCards.length > 0) {
                const card = filteredCards[currentIndex];
                pronounceGerman(card.german);
            }
        });

        // Audio pronunciation - English
        audioBtnEnglish.addEventListener('click', (e) => {
            e.stopPropagation();
            if (filteredCards.length > 0) {
                const card = filteredCards[currentIndex];
                pronounceEnglish(card.english);
            }
        });

        // Reveal button click
        revealBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            revealEnglish();
        });

        // Always show meanings checkbox
        alwaysShowMeaningsCheckbox.addEventListener('change', (e) => {
            alwaysShowMeanings = e.target.checked;
            showFlashcard(); // Refresh current card
        });

        // Read extended content checkbox
        document.getElementById('readExtendedContent').addEventListener('change', (e) => {
            readExtendedContent = e.target.checked;
        });

        // Auto-play button
        autoplayBtn.addEventListener('click', () => {
            if (isAutoPlaying) {
                stopAutoPlay();
            } else {
                startAutoPlay();
            }
        });

        // Auto-play English checkbox
        autoplayEnglishCheckbox.addEventListener('change', (e) => {
            autoplayEnglishEnabled = e.target.checked;
        });

        // Delay sliders
        delayBetweenSlider.addEventListener('input', (e) => {
            delayBetweenLangs = parseInt(e.target.value);
            delayBetweenValue.textContent = (delayBetweenLangs / 1000).toFixed(1) + 's';
        });

        delayNextSlider.addEventListener('input', (e) => {
            delayBeforeNext = parseInt(e.target.value);
            delayNextValue.textContent = (delayBeforeNext / 1000).toFixed(1) + 's';
        });

        // Voice selection handlers
        document.getElementById('germanVoiceSelect').addEventListener('change', (e) => {
            const germanVoices = allVoices.filter(voice => voice.lang.startsWith('de'));
            germanVoice = germanVoices[parseInt(e.target.value)];
            updateVoiceInfo('german', germanVoice);
            console.log('German voice changed to:', germanVoice.name);
        });

        document.getElementById('englishVoiceSelect').addEventListener('change', (e) => {
            const englishVoices = allVoices.filter(voice => voice.lang.startsWith('en'));
            englishVoice = englishVoices[parseInt(e.target.value)];
            updateVoiceInfo('english', englishVoice);
            console.log('English voice changed to:', englishVoice.name);
        });

        // Speech rate handler
        document.getElementById('speechRate').addEventListener('input', (e) => {
            speechRate = parseFloat(e.target.value);
            document.getElementById('speechRateValue').textContent = speechRate.toFixed(1) + 'x';
        });

        // Pitch handler
        document.getElementById('speechPitch').addEventListener('input', (e) => {
            speechPitch = parseFloat(e.target.value);
            document.getElementById('speechPitchValue').textContent = speechPitch.toFixed(1);
        });

        // Advanced features event listeners
        document.getElementById('loopMode').addEventListener('change', (e) => {
            loopModeEnabled = e.target.checked;
        });

        document.getElementById('repeatMode').addEventListener('change', (e) => {
            repeatModeEnabled = e.target.checked;
        });

        document.getElementById('repeatCount').addEventListener('change', (e) => {
            repeatCount = parseInt(e.target.value);
        });

        document.getElementById('studyTimer').addEventListener('change', (e) => {
            studyTimerEnabled = e.target.checked;
            if (!e.target.checked && timerInterval) {
                stopAllTimers();
            }
        });

        document.getElementById('sleepTimer').addEventListener('change', (e) => {
            sleepTimerEnabled = e.target.checked;
            if (!e.target.checked && timerInterval) {
                stopAllTimers();
            }
        });

        // Accordion toggle function
        function toggleAccordion(header) {
            const content = header.nextElementSibling;
            const wasActive = header.classList.contains('active');

            // Close all accordions first (optional - remove if you want multiple open)
            // document.querySelectorAll('.accordion-header').forEach(h => {
            //     h.classList.remove('active');
            //     h.nextElementSibling.classList.remove('active');
            // });

            // Toggle current accordion
            if (wasActive) {
                header.classList.remove('active');
                content.classList.remove('active');
            } else {
                header.classList.add('active');
                content.classList.add('active');

                // Auto-scroll to make the expanded section visible
                setTimeout(() => {
                    const settingsMenu = document.getElementById('settingsMenu');
                    const headerRect = header.getBoundingClientRect();
                    const menuRect = settingsMenu.getBoundingClientRect();

                    // Check if header is above the visible area
                    if (headerRect.top < menuRect.top) {
                        header.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }
                }, 100);
            }
        }

        // Settings menu toggle
        document.getElementById('settingsToggleBtn').addEventListener('click', function() {
            const menu = document.getElementById('settingsMenu');
            const isVisible = menu.style.display === 'block';

            if (isVisible) {
                menu.style.display = 'none';
                this.classList.remove('active');
            } else {
                menu.style.display = 'block';
                this.classList.add('active');
            }
        });

        // Focus Mode button
        document.getElementById('focusModeBtn').addEventListener('click', () => {
            enterFocusMode();
            // Clone the current flashcard to focus mode
            const mainCard = document.getElementById('flashcard');
            const focusCard = document.getElementById('focusFlashcard');
            focusCard.innerHTML = mainCard.innerHTML;
        });

        // Navigation
        prevBtn.addEventListener('click', () => {
            stopAutoPlay(); // Stop auto-play on manual navigation
            if (currentIndex > 0) {
                currentIndex--;
                showFlashcard();
            }
        });

        nextBtn.addEventListener('click', () => {
            stopAutoPlay(); // Stop auto-play on manual navigation
            if (currentIndex < filteredCards.length - 1) {
                currentIndex++;
                showFlashcard();
            }
        });

        // Shuffle cards
        shuffleBtn.addEventListener('click', () => {
            for (let i = flashcards.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [flashcards[i], flashcards[j]] = [flashcards[j], flashcards[i]];
            }
            currentIndex = 0;
            showFlashcard();
        });

        // Mark as learned/unlearned
        learnedBtn.addEventListener('click', () => {
            if (filteredCards.length === 0) return;

            // First reveal the English meaning if not visible
            if (!alwaysShowMeanings && !englishSection.classList.contains('revealed')) {
                revealEnglish();
                // Give user a moment to see the meaning before marking
                setTimeout(() => {
                    markCardAsLearned();
                }, 300);
            } else {
                markCardAsLearned();
            }
        });

        function markCardAsLearned() {
            const card = filteredCards[currentIndex];

            if (!card.learned) {
                // Mark as learned and apply spaced repetition
                // Quality 4 = good recall (default when marking as learned)
                const reviewData = calculateNextReview(card, 4);
                card.learned = true;
                card.repetitions = reviewData.repetitions;
                card.easeFactor = reviewData.easeFactor;
                card.interval = reviewData.interval;
                card.reviewDate = reviewData.reviewDate;
            } else {
                // Unmark as learned and reset spaced repetition
                card.learned = false;
                card.repetitions = 0;
                card.interval = 1;
                card.reviewDate = null;
            }

            updateStats();
            showFlashcard();

            // Auto-advance to next unlearned card if in "show only unlearned" mode
            if (showOnlyUnlearned && card.learned) {
                if (filteredCards.length > 0) {
                    showFlashcard();
                }
            }
        }

        // Reset all progress
        resetBtn.addEventListener('click', () => {
            if (confirm('Reset all progress? This will unmark all learned cards and clear review schedules.')) {
                flashcards.forEach(card => {
                    card.learned = false;
                    card.repetitions = 0;
                    card.interval = 1;
                    card.reviewDate = null;
                });
                updateStats();
                showFlashcard();
            }
        });

        // Toggle show only unlearned
        showLearnedBtn.addEventListener('click', () => {
            showOnlyUnlearned = !showOnlyUnlearned;

            if (showOnlyUnlearned) {
                showLearnedBtn.textContent = 'üëÅ Show All Cards';
                showLearnedBtn.classList.add('active');
            } else {
                showLearnedBtn.textContent = 'üëÅ Show Only Unlearned';
                showLearnedBtn.classList.remove('active');
            }

            currentIndex = 0;
            showFlashcard();
        });

        // Remap columns button - show format selector again
        document.getElementById('remapColumnsBtn').addEventListener('click', () => {
            if (!rawFileData) {
                alert('Please load a file first!');
                return;
            }
            const lines = rawFileData.split('\n').filter(line => line.trim() !== '');
            showFormatSelector(lines, detectedSeparator);
        });

        // Recording event listeners
        document.getElementById('stopRecordingBtn').addEventListener('click', () => {
            stopRecording();
        });

        document.getElementById('downloadRecordingBtn').addEventListener('click', () => {
            downloadRecording();
        });

        document.getElementById('playRecordingBtn').addEventListener('click', () => {
            playRecording();
        });

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (flashcards.length === 0) return;

            switch(e.key) {
                case 'ArrowLeft':
                    stopAutoPlay(); // Stop auto-play on manual navigation
                    if (currentIndex > 0) {
                        currentIndex--;
                        showFlashcard();
                    }
                    break;
                case 'ArrowRight':
                    stopAutoPlay(); // Stop auto-play on manual navigation
                    if (currentIndex < filteredCards.length - 1) {
                        currentIndex++;
                        showFlashcard();
                    }
                    break;
                case ' ':
                case 'Enter':
                    e.preventDefault();
                    if (!alwaysShowMeanings && !englishSection.classList.contains('revealed')) {
                        revealEnglish();
                    }
                    break;
                case 'l':
                case 'L':
                    // Quick keyboard shortcut for marking as learned
                    if (filteredCards.length > 0) {
                        // First reveal the English meaning if not visible
                        if (!alwaysShowMeanings && !englishSection.classList.contains('revealed')) {
                            revealEnglish();
                            setTimeout(() => {
                                markCardAsLearned();
                            }, 300);
                        } else {
                            markCardAsLearned();
                        }
                    }
                    break;
                case 'p':
                case 'P':
                    // Quick keyboard shortcut for German pronunciation
                    if (filteredCards.length > 0) {
                        const card = filteredCards[currentIndex];
                        pronounceGerman(card.german);
                    }
                    break;
                case 'e':
                case 'E':
                    // Quick keyboard shortcut for English pronunciation
                    if (filteredCards.length > 0) {
                        const card = filteredCards[currentIndex];
                        pronounceEnglish(card.english);
                    }
                    break;
            }
        });
    </script>

    <!-- Focus Mode Overlay -->
    <div class="focus-mode" id="focusMode">
        <button class="focus-exit-btn" onclick="exitFocusMode()">‚úï Exit Focus Mode</button>
        <div class="flashcard-container">
            <div class="flashcard" id="focusFlashcard">
                <!-- Will be cloned from main flashcard -->
            </div>
        </div>
    </div>

</body>
</html>
